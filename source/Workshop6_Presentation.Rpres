Workshop 6: Working with Data Frames
========================================================
author: Cassandra Buzby & Yen-Chung Chen
date: `r Sys.Date()`
autosize: true

Pairs Today
=======================================================

## Esther/Alejandra

## Filip/Yarek

## Melchi/Kaitriana

## Temima/Natalya

Review
========================================================
incremental: true
Vectors can be combined to create data frames. First, let's make three vectors of length 30:
```{r}
vector1 <- 1:30
vector2 <- seq(0,100,length.out = 30)
vector3 <- seq(12,1, length.out = 30)
```

```{r}
length(vector1)
length(vector2)
length(vector3)
```

Review
========================================================
incremental: true
Next, we can use the data.frame() function to combine these vectors into columns:
```{r}
data.frame(vector1, vector2, vector3)
```

Review
========================================================
incremental: true
We can also name the columns by defining each within the function data.frame() or by using the colnames() function.
```{r}
mydataframe <- data.frame(plate = vector1, survival = vector2, dose = vector3)
head(mydataframe,3)
```
```{r}
colnames(mydataframe) <- c("Plate", "Percent_Survived", "Dose")
head(mydataframe,3)
```

Review: Subsetting Vectors
==========
incremental: true
Some data frames have column **names** and all data frames have row-column **positions**. You can identify a value in a data frame by indicating the position in the column (essentially, the position in the vector) of a row, or by referencing the [row,column] number.

```{r}
mydataframe$Plate[2]
mydataframe[2,1]
mydataframe[1,2]
```

Practice
==========
1. Add together the third and fourth rows of your data frame.
2. Subset the third column of your data frame and save it as a new variable, then view the first 4 elements of this variable using head().
3. Find the mean of the second column of your data frame

Practice
==========
1. Add together the third and fourth rows of your data frame.
2. Subset the third column of your data frame and save it as a new variable, then view the first 4 elements of this variable using head().
3. Find the mean of the second column of your data frame

Practice
==========
1. Add together the third and fourth rows of your data frame.
```{r}
mydataframe[3,] + mydataframe[4,]

```

* Subset the third column of your data frame and save it as a new variable, then view the first 4 elements of this variable using head().

* Find the mean of the second column of your data frame



Practice
==========
1. Add together the third and fourth rows of your data frame.
2. Subset the third column of your data frame and save it as a new variable, then view the first 4 elements of this variable using head().

```{r}

newvariable <- mydataframe[,3]
head(newvariable, 4)

```

* Find the mean of the second column of your data frame


Practice
==========
1. Add together the third and fourth rows of your data frame.
2. Subset the third column of your data frame and save it as a new variable, then view the first 4 elements of this variable using head().
3. Find the mean of the second column of your data frame

```{r}
mean(mydataframe[,2])
```

Review: Logicals
==========

Just like you can make a vector of characters or a vector of numeric values, you can also make a vector of logicals.
```{r}
# Make a vector with 3 TRUEs and 2 FALSEs, save it as logical_vec1

# Make a vector called num_vec that starts at 2 and ends at 10 (increasing by 1)
```
```{r}
logical_vec1 <- c(TRUE,TRUE,TRUE,FALSE,FALSE)
num_vec <- c(2:100)
```
```{r}
logical_vec2 <- num_vec %% 3 == 2 #what is this line of code doing?
```

Treating numbers as logicals
================
incremental: true

In R, FALSE is also encoded as 0, and TRUE is encoded as 1. 

1. How do you think we could easily figure out *how many* TRUEs there are in logical_vec2?
2. What function will tell us which of these elements are TRUEs?

```{r}
sum(logical_vec2)
```
```{r}
which(logical_vec2)
```
```{r}
length(which(logical_vec2))
```


Expanding on Logical Operations (AND, OR)
=======
incremental: true
We can also do "and" (`&`) and "or" (`|`, all the way on the right side of your keyboard). "And" only returns true if both things are true. "Or" returns true if at least one thing is true.

Try predicting what all the operations below will return
```{r}
TRUE & TRUE
TRUE & FALSE
FALSE & FALSE
FALSE | TRUE
```


===========
# Working with Data Frames

Working with Data Frames
==========
incremental: true
R has several built-in data sets to use as examples, such as the Iris dataset. Try viewing part of it using head(iris).

```{r}
head(iris)
```

Working with Data Frames
==========
incremental: true
Often, you'll have to work with data compiled into a table, and you'll want to see what you're working with when you load it in to R. Some functions that you can use are dim() for dimensions or str() for the type of data that you have.
```{r}
dim(iris)
```

```{r}
str(iris)
```

Working with Data Frames
==========
incremental: true
Several functions can also describe your data, such as min(), max(), and quantile(). A quantile demonstrates how much of your data lies below a certain value, or when given a distribution, the value at which the given percentage of your data lies below it. (For example, at 0.5, the function would return the median).
```{r}
quantile(iris$Sepal.Length)
min(iris$Sepal.Length)
median(iris$Sepal.Length)
max(iris$Sepal.Length)
```

Exercise
==========
incremental: true
Once you have this data, you might want to select from the data frame all of the values that are in the top or bottom 10% of a value. Use quantile() to find these values for Petal Length in the iris dataset.

```{r}
quantile(iris$Petal.Length, c(0.1, 0.9))
```

```{r}
#What is happening here?
quantile(iris$Petal.Length, 0.1, 0.9)
```

Exercise
========
incremental: true

You want to extract the **rows** which include the top 10% of your Petal Length data. 

1. Use quantile() to find the cutoff for your top 10% of Petal Length values
2. Use which() to identify which values of iris$Petal.Length are in the top 10% of petal lengths (hint: use a logical operator for this comparison)
3. Subset the iris data frame to print the **entire row** of these top 10% values

```{r}
quantile(iris$Petal.Length, 0.9)
which(iris$Petal.Length >= quantile(iris$Petal.Length, 0.9))
```

Exercise
========
You want to extract the **rows** which include the top 10% of your Petal Length data. 

1. Use quantile() to find the cutoff for your top 10% of Petal Length values
2. Use which() to identify which values of iris$Petal.Length are in the top 10% of petal lengths (hint: use a logical operator for this comparison)
3. Subset the iris data frame to print the **entire row** of these top 10% values
```{r}
iris[which(iris$Petal.Length >= quantile(iris$Petal.Length, 0.9)),]
```

Penguins
=================

```{r, echo = FALSE}
if (dir.exists('class_1_figures')){
  library(knitr)
  include_graphics('class_1_figures/penguins.png')
}

```

Note: these data were collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER, a member of the Long Term Ecological Research Network, and put together by Dr. Allison Horst. To read more about the dataset, see Allison Horst's website about it here.

Artwork by @allison_horst

Loading in Datasets
==========
incremental: true

Your own data is not already available in R. This is where working directories come back into play. To load in a file, you can use read.csv() or read.table(), which each take in your file name and arguments that tell R how to format your data into a data frame.

First, check your working directory by running getwd(), and see if your file is in this by running dir().
```{r}
getwd()
dir()
```

Loading in Datasets
==========
incremental: true

Load in penguins.csv from the website (it will probably be in your downloads folder) and **save it as a variable**. Without saving to a variable, read.csv() will print the entire dataset into your workspace without saving.
```{r}
#If you type in read.csv(" and then click tab, it should show the available files from your working directory
penguins <- read.csv("penguins.csv", header = TRUE)
head(penguins)
```

A Few New Functions
============================
incremental: true

For the next exercises, it might be helpful to look into the following functions:
```{r}
unique(penguins$species)
table(penguins$island)

#when using sum() or mean(), set na.rm = TRUE
```


Exercise
=============
incremental: true
## With your partner, pick one of the following tasks to complete:

1. Which species of penguin has the largest average bill length? Which species has the smallest bill depth?
2. Make a new data frame including the smallest 10% of flipper lengths and count how many penguins of each species are represented.
3. Is the sampling between islands consistent? How many penguins of each species were sampled from each island?
4. Was the sampling by sex equal each year? How many of the penguins were female each year compared to males?

Exercise
=============
incremental: true
1. Which species of penguin has the largest average bill length? Which species has the smallest bill depth?
```{r}
adelie_BL <- which(penguins$species == "Adelie")
chinstrap_BL <- which(penguins$species == "Chinstrap")
gentoo_BL <- which(penguins$species == "Gentoo")

mean(penguins[adelie_BL, 4], na.rm = TRUE)
mean(penguins[chinstrap_BL, 4], na.rm = TRUE)
mean(penguins[gentoo_BL, 4], na.rm = TRUE)

```

Exercise
=============
incremental: true
2. Make a new data frame including the smallest 10% of flipper lengths and count how many penguins of each species are represented.
```{r}
ten_percent_cutoff <- quantile(penguins$flipper_length_mm, 0.1, na.rm = TRUE)
ten_percent_of_penguins <- penguins[penguins$flipper_length_mm <= ten_percent_cutoff,]

sum(ten_percent_of_penguins$species == "Adelie", na.rm = TRUE)
sum(ten_percent_of_penguins$species == "Chinstrap", na.rm = TRUE)
sum(ten_percent_of_penguins$species == "Gentoo", na.rm = TRUE)

#alternatively:
table(ten_percent_of_penguins)

```


Exercise
=============
incremental: true
3. Is the sampling between islands consistent? How many penguins of each species were sampled from each island?
```{r}
table(penguins$species[penguins$island == "Biscoe"])
table(penguins$species[penguins$island == "Dream"])
table(penguins$species[penguins$island == "Torgersen"])

```


Exercise
=============
incremental: true
4. Was the sampling by sex equal each year? How many of the penguins were female each year compared to males?
```{r}
penguins07 <- penguins[penguins$year == 2007,]
length(penguins07$year[penguins07$sex == "female"])/length(penguins07$year)
```

```{r}
numbers08 <- which(penguins$year == 2008)
penguins08 <- penguins[numbers08,]

table(penguins08$sex)
```

```{r}
penguins09 <- penguins[penguins$year == 2009,]
sum(penguins09$sex == "female", na.rm = TRUE)/sum(penguins09$sex == "male", na.rm = TRUE)
```


Functions
====================
incremental: true

The three main parts of a function are (1) the **input**, (2) the action itself, and (3) the **output**. To better understand these elements, we are going to build our own function.

```{r}
myfunction <- function(x){x+2}
```

We can use this function by running:
```{r}
myfunction(12)
```

Functions
=================
Let's build a function that returns an encouraging statement. We can use the function sample() to randomly choose a compliment from a vector of strings. Let's first make the vector of strings:

```{r}
a <- "You're doing great!"
b <- "Research is hard, but perserverence is the key to success"
c <- "I'm glad to see you here today"

compliments <- c(a,b,c)

```

Functions
===============
Next, we want to sample from these compliments

```{r}
sample(compliments, 1)
```

Functions
=================
incremental: true
Finally, we'll want a function to give a random compliment every time the function is used. Let's name this function "complimentme" and have it not require any input:

```{r}
complimentme <- function(){
  a <- "You're doing great!"
  b <- "You are doing awesome science"
  c <- "I'm glad to see you here today"

  compliments <- c(a,b,c)
  return(sample(compliments, 1))

}
```

```{r}
complimentme()
```

Functions
==============
incremental: true
Finally, if we want to tell R how many compliments to give, you can add an input:

```{r}
complimentme <- function(x = 1){
  a <- "You're doing great!"
  b <- "You are doing awesome science"
  c <- "I'm glad to see you here today"

  compliments <- c(a,b,c)
  return(sample(compliments, x))
}

```

```{r}
complimentme(3)
```
