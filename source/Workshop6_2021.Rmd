---
title: 'Workshop 6: Working With Data Frames'
author: "Cassandra Buzby & Yen-Chung Chen"
date: "7/8/2021"
output: html_document
---

# Review

Vectors can be combined to create data frames. First, let's make three vectors of length 30:
```{r}
vector1 <- 1:30
vector2 <- seq(0,100,length.out = 30)
vector3 <- seq(12,1, length.out = 30)
```

```{r}
length(vector1)
length(vector2)
length(vector3)
```


Next, we can use the data.frame() function to combine these vectors into columns:
```{r}
data.frame(vector1, vector2, vector3)
```


We can also name the columns by defining each within the function data.frame() or by using the colnames() function.
```{r}
mydataframe <- data.frame(plate = vector1, survival = vector2, dose = vector3)
head(mydataframe,3)
```

```{r}
colnames(mydataframe) <- c("Plate", "Percent_Survived", "Dose")
head(mydataframe,3)
```


Some data frames have column **names** and all data frames have row-column **positions**. You can identify a value in a data frame by indicating the position in the column (essentially, the position in the vector) of a row, or by referencing the [row,column] number.

```{r}
mydataframe$Plate[2]
mydataframe[2,1]
mydataframe[1,2]
```

Practice
```{r}
# 1. Add together the third and fourth rows of your data frame.


# 2. Subset the third column of your data frame and save it as a new variable, then view the first 4 elements of this variable using head().


# 3. Find the mean of the second column of your data frame


```

# Review: Logicals

Just like you can make a vector of characters or a vector of numeric values, you can also make a vector of logicals.
```{r}
# Make a vector with 3 TRUEs and 2 FALSEs, save it as logical_vec1

# Make a vector called num_vec that starts at 2 and ends at 10 (increasing by 1)

```

What is this line of code doing?
```{r, eval = FALSE}
logical_vec2 <- num_vec %% 3 == 2 
```

Treating numbers as logicals
================
incremental: true

In R, FALSE is also encoded as 0, and TRUE is encoded as 1. 


```{r}
# 1. How do you think we could easily figure out *how many* TRUEs there are in logical_vec2?
# 2. What function will tell us which of these elements are TRUEs?

```


Expanding on Logical Operations (AND, OR)
=======
incremental: true
We can also do "and" (`&`) and "or" (`|`, all the way on the right side of your keyboard). "And" only returns true if both things are true. "Or" returns true if at least one thing is true.

Try predicting what all the operations below will return
```{r}
TRUE & TRUE
TRUE & FALSE
FALSE & FALSE
FALSE | TRUE
```


# Working with Data Frames

R has several built-in data sets to use as examples, such as the Iris dataset. Try loading it in my using head(iris).

```{r}
head(iris)
```


Often, you'll have to work with data compiled into a table, and you'll want to see what you're working with when you load it in to R. Some functions that you can use are dim() for dimensions or str() for the type of data that you have.
```{r}
dim(iris)
```

```{r}
str(iris)
```

Several functions can also describe your data, such as min(), max(), and quantile(). Quantile() returns the value that is the value at which your input (a probability) is above. 
```{r}
quantile(iris$Sepal.Length)
min(iris$Sepal.Length)
median(iris$Sepal.Length)
max(iris$Sepal.Length)
```


## Exercise
Once you have this data, you might want to select from the data frame all of the values that are in the top or bottom 10% of a value. Use quantile() to find these values for Petal Length in the iris dataset.

```{r}
quantile(iris$Petal.Length, c(0.1, 0.9))
```

You want to extract the **rows** which include the top 10% of your Petal Length data. 

```{r}
# 1. Use quantile() to find the cutoff for your top 10% of Petal Length values


# 2. Use which() to identify which values of iris$Petal.Length are in the top 10% of petal lengths (hint: use a logical operator for this comparison)


# 3. Subset the iris data frame to print the **entire row** of these top 10% values

```

# Loading In Data

Obviously your own data is not already in R. This is where working directories come back into play. To load in a file, you can use read.csv() or read.table(), which each take in your file name and arguments that tell R how to format your data into a data frame.

Load in penguins.csv from the website (it will probably be in your downloads folder) and **save it as a variable**. Without saving to a variable, read.csv() will print the entire dataset into your workspace without saving.
```{r}
penguins <- read.csv("penguins.csv", header = TRUE)
head(penguins)
```

## A Few New Functions

For the next exercises, it might be helpful to look into the following functions:
```{r}
unique(penguins$species)
table(penguins$island)

#when using sum() or mean(), set na.rm = TRUE
```


Exercise
=============
With your partner, pick one of the following tasks to complete:
```{r}
# 1. Which species of penguin has the largest average bill length? Which species has the smallest bill depth?
  



```

```{r}
# 2. Make a new data frame including the smallest 10% of flipper lengths and count how many penguins of each species are represented.




```

```{r}
# 3. Is the sampling between islands consistent? How many penguins of each species were sampled from each island?




```

```{r}
# 4. Was the sampling by sex equal each year? How many of the penguins were female each year compared to males?




```

# Functions

The three main parts of a function are (1) the **input**, (2) the action itself, and (3) the **output**. To better understand these elements, we are going to build our own function.

```{r}
myfunction <- function(x){x+2}
```

We can use this function by running:
```{r}
myfunction(12)
```

## Build Your Own Function!

Let's build a function that returns an encouraging statement. We can use the function sample() to randomly choose a compliment from a vector of strings. Let's first make the vector of strings:

```{r}
a <- "You're doing great!"
b <- "Research is hard, but perserverence is the key to success"
c <- "I'm glad to see you here today"

compliments <- c(a,b,c)

```

Next, we want to sample from these compliments

```{r}
sample(compliments, 1)
```

Finally, we'll want a function to give a random compliment every time the function is used. Let's name this function "complimentme" and have it not require any input:

```{r}
complimentme <- function(){
  a <- "You're doing great!"
  b <- "You are doing awesome science"
  c <- "I'm glad to see you here today"

  compliments <- c(a,b,c)
  return(sample(compliments, 1))

}
```

```{r}
complimentme()
```

How would you add an input of telling R how many compliments to give you?
```{r}
# Change the complimentme() function to return a user-defined number of compliments




```
