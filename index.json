[{"authors":["ycc"],"categories":null,"content":"Hello, I am a PhD candidate in the Desplan lab at New York University. I study genetic programs that specify different kind of neurons in development. Using fly visual system as my model, I aim to learn how important regulators, like those implicated in spatial and temporal patterning, interacts and defines neuronal fates in development.\n","date":1657756800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1657833389,"objectID":"d4aa3023f78e5f3d87ffdc9938d558a3","permalink":"https://nyusurp.github.io/author/yen-chung-chen/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/yen-chung-chen/","section":"authors","summary":"Hello, I am a PhD candidate in the Desplan lab at New York University. I study genetic programs that specify different kind of neurons in development. Using fly visual system as my model, I aim to learn how important regulators, like those implicated in spatial and temporal patterning, interacts and defines neuronal fates in development.","tags":null,"title":"Yen-Chung Chen","type":"authors"},{"authors":["cb"],"categories":null,"content":"I am interested in understanding the prevalence and nature of genetic interactions in complex traits. Through growth rate assays, bulk segregant analysis, and comparative models of genetic architecture in budding yeast, we can make headway in characterizing epistasis.\n","date":1657152000,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1657832287,"objectID":"4d2640abaaada3be20dbebb4aa26601d","permalink":"https://nyusurp.github.io/author/cassandra-buzby/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/cassandra-buzby/","section":"authors","summary":"I am interested in understanding the prevalence and nature of genetic interactions in complex traits. Through growth rate assays, bulk segregant analysis, and comparative models of genetic architecture in budding yeast, we can make headway in characterizing epistasis.","tags":null,"title":"Cassandra Buzby","type":"authors"},{"authors":["admin"],"categories":null,"content":"R Workshop for NYU SURP is a 10-session workshop focused on data exploration, visualization, and hypothesis testing. Taking advantage of the simple yet powerful tools developed by the R community, we aim to provide a lever to explore the ever-growing mass of data in biology and to develop insight by generating and testing hypotheses with various visualization and statistical techniques.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://nyusurp.github.io/author/site-admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/site-admin/","section":"authors","summary":"R Workshop for NYU SURP is a 10-session workshop focused on data exploration, visualization, and hypothesis testing. Taking advantage of the simple yet powerful tools developed by the R community, we aim to provide a lever to explore the ever-growing mass of data in biology and to develop insight by generating and testing hypotheses with various visualization and statistical techniques.","tags":null,"title":"Site admin","type":"authors"},{"authors":["Yen-Chung Chen"],"categories":["handout"],"content":" Quick recap/practice To warm up, we’re going to use one of Cassandra’s data sets, which has chromosome positions and z-scores. We’ll do each of these exercises together.\n# Load in the data BSAResults = read.csv(\u0026quot;data/BSAResults.csv\u0026quot;) # Find the unique values of the chromosomes. How do we find the column name? str(BSAResults) ## \u0026#39;data.frame\u0026#39;: 49432 obs. of 6 variables: ## $ X : chr \u0026quot;result.1\u0026quot; \u0026quot;result.2\u0026quot; \u0026quot;result.3\u0026quot; \u0026quot;result.4\u0026quot; ... ## $ CHROM : chr \u0026quot;I\u0026quot; \u0026quot;I\u0026quot; \u0026quot;I\u0026quot; \u0026quot;I\u0026quot; ... ## $ POS : num 100007 1035 1074 1101 1173 ... ## $ Bulk : num -0.08758 0.1827 -0.00987 0.01895 0.87397 ... ## $ Parent : num 3.554 0.537 -0.345 -0.12 -0.393 ... ## $ Interaction: num -0.01715 0.13848 0.31904 -0.00762 -0.18258 ... unique(BSAResults$CHROM) ## [1] \u0026quot;I\u0026quot; \u0026quot;II\u0026quot; \u0026quot;III\u0026quot; \u0026quot;IV\u0026quot; \u0026quot;V\u0026quot; \u0026quot;VI\u0026quot; \u0026quot;VII\u0026quot; \u0026quot;VIII\u0026quot; \u0026quot;IX\u0026quot; \u0026quot;X\u0026quot; ## [11] \u0026quot;XI\u0026quot; \u0026quot;XII\u0026quot; \u0026quot;XIII\u0026quot; \u0026quot;XIV\u0026quot; \u0026quot;XV\u0026quot; \u0026quot;XVI\u0026quot; # Filter for Chromosome II using dplyr\u0026#39;s filter() function, and pipe through head() to output only the first 10 lines BSAResults %\u0026gt;% filter(CHROM == \u0026quot;II\u0026quot;) %\u0026gt;% head(., n = 10) ## X CHROM POS Bulk Parent Interaction ## 1 result.11000 II 100153 -0.18330726 -0.0646732103 0.19943965 ## 2 result.21000 II 100367 -0.18800155 -0.2912844665 0.28590390 ## 3 result.31000 II 100413 -0.32764216 -0.3031255854 0.52362311 ## 4 result.41000 II 100878 0.02040887 0.1185267276 -0.16398910 ## 5 result.51000 II 101103 -0.13385976 -0.0100344121 -0.01602947 ## 6 result.6432 II 101289 -0.25282081 0.0817157785 0.21342401 ## 7 result.7100 II 101340 -0.19522650 0.1584760726 -0.15293462 ## 8 result.8100 II 10136 -0.30926532 -0.0078019497 -0.02303257 ## 9 result.9100 II 101507 -0.19850031 -0.0007044734 0.08039453 ## 10 result.10100 II 101581 0.07333291 0.0641751118 -0.28421660 # Plot a scatter plot of the Bulk with x-axis being POS and y-axis being Bulk values BSAResults %\u0026gt;% filter(CHROM == \u0026quot;II\u0026quot;) %\u0026gt;% ggplot(., aes(x = POS, y = Bulk)) + geom_point() # If we want plot Bulk, Interaction, and Parent for Chr II at once, we need to pivot the data to long format. How do we do so? BSAResults %\u0026gt;% pivot_longer(., cols = c(Bulk, Interaction, Parent)) %\u0026gt;% head() ## # A tibble: 6 × 5 ## X CHROM POS name value ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; ## 1 result.1 I 100007 Bulk -0.0876 ## 2 result.1 I 100007 Interaction -0.0171 ## 3 result.1 I 100007 Parent 3.55 ## 4 result.2 I 1035 Bulk 0.183 ## 5 result.2 I 1035 Interaction 0.138 ## 6 result.2 I 1035 Parent 0.537 # Then to plot, we can separate our data by \u0026quot;name\u0026quot; - rename this column \u0026quot;Z_score\u0026quot; using pivot_longer() BSAResults %\u0026gt;% pivot_longer(., cols = c(Bulk, Interaction, Parent), names_to = \u0026quot;Z_score\u0026quot;) %\u0026gt;% # There\u0026#39;s a more interesting thing happening on Chr VIII. Filter for this instead. filter(CHROM == \u0026quot;VIII\u0026quot;) %\u0026gt;% # Plot the pivoted points with them colored by Z_score. ggplot(., aes(x = POS, y = value, color = Z_score)) + geom_point() # There are a lot of points. Change the opacity of these points. BSAResults %\u0026gt;% pivot_longer(., cols = c(Bulk, Interaction, Parent), names_to = \u0026quot;Z_score\u0026quot;) %\u0026gt;% filter(CHROM == \u0026quot;VIII\u0026quot;) %\u0026gt;% ggplot(., aes(x = POS, y = value, color = Z_score)) + geom_point(alpha = 0.3) # We now want to change the names to reflect what the value actually is. Add labels to the plot. BSAResults %\u0026gt;% pivot_longer(., cols = c(Bulk, Interaction, Parent), names_to = \u0026quot;Z_score\u0026quot;) %\u0026gt;% filter(CHROM == \u0026quot;VIII\u0026quot;) %\u0026gt;% ggplot(., aes(x = POS, y = value, color = Z_score)) + geom_point(alpha = 0.3) + xlab(\u0026quot;Coordinate on Chromsome (nt)\u0026quot;) + ylab(\u0026quot;Z-Score\u0026quot;) + ggtitle(\u0026quot;The Light from the Other End of the Tunnel\u0026quot;) + # A different theme might be better. Let\u0026#39;s use theme_classic() theme_classic() # BONUS: it would be great to plot all chromosomes on the plot at once. Add facet_grid(~CHROM) to do this, and once it works, remove the filtering of your CHROM column. BSAResults %\u0026gt;% pivot_longer(., cols = c(Bulk, Interaction, Parent), names_to = \u0026quot;Z_score\u0026quot;) %\u0026gt;% # filter(CHROM == \u0026quot;VIII\u0026quot;) %\u0026gt;% ggplot(., aes(x = POS, y = value, color = Z_score)) + geom_point(alpha = 0.3, size = 0.1) + xlab(\u0026quot;Coordinate on Chromsome (nt)\u0026quot;) + ylab(\u0026quot;Z-Score\u0026quot;) + ggtitle(\u0026quot;The One where Everything is Plotted Together\u0026quot;) + theme_classic() + facet_grid(~CHROM, space = \u0026quot;free_x\u0026quot;) + # NEW: Another way to limit the y coord_cartesian(ylim = c(-1.5, 1.5)) + guides(color = \u0026quot;none\u0026quot;) Today, we will be looking into the first figure from Massively parallel Cas13 screens reveal principles for guide RNA design from the Sanjana Lab.\nThe main reason we selected this paper is because: First, the visualization they used are fairly popular and meets what we covered in previous sessions; second, they did an excellent job in sharing their data and code, so you will have this unique chance to work with real data and know exactly how the authors performed their analyses and visualization if you take the time to read their code.\n Figure 1b: BoxPlot Figure 1b is a panel of boxplots showing log-transformed enrichment scores of different types of crRNAs (the equivalent to sgRNAs for Cas13a).\nThe processed (normalized and batch-corrected) data for crRNAs in this tiling screen is provided in data/GFP_screen_crRNA_enrichments.csv. Specifically:\n crRNAs are categorized in to several categories based on their targets in type Log-transformed enrichment scores are stored in meanCS.BIN1  First, let’s load in the data and see what it looks like\n#Load in our data GFP_Results = read.csv(\u0026quot;data/GFP_screen_crRNA_enrichments.csv\u0026quot;) #See what the data looks like str(GFP_Results) ## \u0026#39;data.frame\u0026#39;: 7500 obs. of 17 variables: ## $ p.BIN1 : num 0.03714 0.00531 0.05278 0.00993 0.81008 ... ## $ p.BIN2 : num 0.00441 0.06989 1 0.31136 1 ... ## $ p.BIN3 : num 0.0164 0.038 0.3089 0.2385 0.6272 ... ## $ p.BIN4 : num 0.1162 0.0542 0.2063 0.012 0.8689 ... ## $ logBIN1 : num 1.4302 2.2752 1.2776 2.0029 0.0915 ... ## $ logBIN2 : num 2.355 1.156 0 0.507 0 ... ## $ logBIN3 : num 1.785 1.42 0.51 0.622 0.203 ... ## $ logBIN4 : num 0.935 1.266 0.686 1.923 0.061 ... ## $ meanCS.BIN1 : num 0.698 0.973 1.167 1.055 0.953 ... ## $ meanCS.BIN2 : num -0.6699 -0.2926 -0.0292 -0.3766 NA ... ## $ meanCS.BIN3 : num -0.923 -0.469 -0.589 -0.499 -0.852 ... ## $ meanCS.BIN4 : num -0.658 -0.408 -0.573 -0.689 -0.67 ... ## $ medianCS.BIN1: num 0.742 0.97 1.167 1.235 0.953 ... ## $ medianCS.BIN2: num -0.6353 -0.2197 -0.0292 -0.0923 NA ... ## $ medianCS.BIN3: num -1.019 -0.446 -0.589 -0.458 -0.852 ... ## $ medianCS.BIN4: num -0.774 -0.398 -0.573 -0.762 -0.67 ... ## $ type : chr \u0026quot;Perfect Match\u0026quot; \u0026quot;Perfect Match\u0026quot; \u0026quot;Perfect Match\u0026quot; \u0026quot;Perfect Match\u0026quot; ... Next we want to change the “type” column into factors. We can do this by using the function factor() which we went over last class, and then add the labels function to change the words into acronyms.\n# Note that each type is: # 1. Represented as acronyms in the figure # 2. Are NOT arranged in alphabetical order # We can see the need to transform the type column to a factor GFP_Results$type = factor( x = GFP_Results$type, levels = c( \u0026quot;Perfect Match\u0026quot;, \u0026quot;First Order\u0026quot;, \u0026quot;Random Double\u0026quot;, \u0026quot;Consecutive Double\u0026quot;, \u0026quot;Consecutive Triple\u0026quot;, \u0026quot;Non-Targeting\u0026quot; ), labels = c( \u0026quot;PM\u0026quot;, \u0026quot;SM\u0026quot;, \u0026quot;RD\u0026quot;, \u0026quot;CD\u0026quot;, \u0026quot;CT\u0026quot;, \u0026quot;NT\u0026quot; ) ) Next we can make a basic boxplot, using ggplot and filtering for non NA values:\nGFP_Results %\u0026gt;% # This is to remove the rows where meanCS.BIN is NA filter(!is.na(meanCS.BIN1)) %\u0026gt;% #basic elements of the plot ggplot(., aes(x = type, y = meanCS.BIN1)) + geom_boxplot() + #labels ggtitle(\u0026quot;All crRNAs\u0026quot;) + xlab(\u0026quot;\u0026quot;) + ylab(\u0026quot;log2(FC)\u0026quot;) First of all, the colors are different. We can change these by setting the hex codes to match the Sanjana lab’s colors, then inputting this vector of hex codes into the scale_fill_manual() function:\n# The color palette used in the paper #### BONUS: Change the colors and run the chunk to see what happens to the #### plot!! sanjana_colors = c( \u0026quot;#E69F00\u0026quot;, \u0026quot;#D55E00\u0026quot;, \u0026quot;#009E73\u0026quot;, \u0026quot;#0072B2\u0026quot;, \u0026quot;#56B4E9\u0026quot;, \u0026quot;#999999\u0026quot; ) GFP_Results %\u0026gt;% filter(!is.na(meanCS.BIN1)) %\u0026gt;% #basic elements of the plot ggplot(aes(fill = type, x = type, y = meanCS.BIN1)) + geom_boxplot() + #labels xlab(\u0026quot;\u0026quot;) + ylab(\u0026quot;log2(FC)\u0026quot;) + ggtitle(\u0026quot;All crRNAs\u0026quot;) + #colors scale_fill_manual(values = sanjana_colors) We can also make the outliers smaller, using the outlier.shape and outlier.size functions in geom_boxplot().\nGFP_Results %\u0026gt;% filter(!is.na(meanCS.BIN1)) %\u0026gt;% #basic elements of the plot ggplot(aes(fill = type, x = type, y = meanCS.BIN1)) + geom_boxplot(outlier.shape = 20, outlier.size = 0.05) + #labels xlab(\u0026quot;\u0026quot;) + ylab(\u0026quot;log2(FC)\u0026quot;) + ggtitle(\u0026quot;All crRNAs\u0026quot;) + #colors scale_fill_manual(values = sanjana_colors) Next, let’s reduce the white space by adding a ylim argument:\nGFP_Results %\u0026gt;% filter(!is.na(meanCS.BIN1)) %\u0026gt;% #basic elements of the plot ggplot(aes(fill = type, x = type, y = meanCS.BIN1)) + geom_boxplot(outlier.shape = 20, outlier.size = 0.05) + #labels xlab(\u0026quot;\u0026quot;) + ylab(\u0026quot;log2(FC)\u0026quot;) + ggtitle(\u0026quot;All crRNAs\u0026quot;) + #colors scale_fill_manual(values = sanjana_colors) + #y axis limits ylim(c(-1.5,1.5))  ## Warning: Removed 15 rows containing non-finite values (stat_boxplot). Finally, we’re going to use a new function called coord_fixed() to restrict the aspect ratio of the plot.\nGFP_Results %\u0026gt;% filter(!is.na(meanCS.BIN1)) %\u0026gt;% #basic elements of the plot ggplot(aes(fill = type, x = type, y = meanCS.BIN1)) + geom_boxplot(outlier.shape = 20, outlier.size = 0.05) + #labels xlab(\u0026quot;\u0026quot;) + ylab(\u0026quot;log2(FC)\u0026quot;) + ggtitle(\u0026quot;All crRNAs\u0026quot;) + #colors scale_fill_manual(values = sanjana_colors) + #y-axis limits and ratio ylim(c(-1.5,1.5)) + coord_fixed(ratio = 6/3) + # Remove legends guides(fill = \u0026quot;none\u0026quot;) + # Remove x-axis line and tick theme( axis.ticks.x = element_blank(), axis.line.x = element_blank() ) ## Warning: Removed 15 rows containing non-finite values (stat_boxplot). And finally, for a publication-level plot, we’ll remove our legend and x axis ticks using guides() and theme(), and then set our overall theme to theme_classic().\nGFP_Results %\u0026gt;% filter(!is.na(meanCS.BIN1)) %\u0026gt;% #basic elements of the plot ggplot(aes(fill = type, x = type, y = meanCS.BIN1)) + geom_boxplot(outlier.shape = 20, outlier.size = 0.05) + #labels xlab(\u0026quot;\u0026quot;) + ylab(\u0026quot;log2(FC)\u0026quot;) + ggtitle(\u0026quot;All crRNAs\u0026quot;) + #colors scale_fill_manual(values = sanjana_colors) + #y axis limits and ratio ylim(c(-1.5,1.5)) + coord_fixed(ratio = 6/3) + # Remove legends guides(fill = \u0026quot;none\u0026quot;) + theme_classic() + # Remove x-axis line and tick theme( axis.ticks.x = element_blank(), axis.line.x = element_blank() ) ## Warning: Removed 15 rows containing non-finite values (stat_boxplot).   Figure 1c: Scatter plot with jitter Figure 1c is a panel of scatter plots with jitter showing differences in log-transformed enrichment scores of individual crRNAs of different types.\nThe processed data for individual crRNAs is provided in data/GFPTiling_individual.csv. Specifically:\n crRNAs are categorized in to several categories based on their targets in MatchType Differences of log-transformed enrichment scores are stored in DeltaCS  # Load data tiling_result = read.csv(\u0026quot;data/GFPTiling_individual.csv\u0026quot;) # Take a look at your data str(tiling_result) ## \u0026#39;data.frame\u0026#39;: 179 obs. of 10 variables: ## $ Screen : chr \u0026quot;GFP\u0026quot; \u0026quot;GFP\u0026quot; \u0026quot;GFP\u0026quot; \u0026quot;GFP\u0026quot; ... ## $ GuideName : chr \u0026quot;crRNA004:7-33\u0026quot; \u0026quot;crRNA004:7-33_consecDouble_01\u0026quot; \u0026quot;crRNA004:7-33_consecDouble_02\u0026quot; \u0026quot;crRNA004:7-33_consecDouble_03\u0026quot; ... ## $ Guide : chr \u0026quot;crRNA004\u0026quot; \u0026quot;crRNA004\u0026quot; \u0026quot;crRNA004\u0026quot; \u0026quot;crRNA004\u0026quot; ... ## $ MatchType : chr \u0026quot;Perfect Match\u0026quot; \u0026quot;Consecutive Double\u0026quot; \u0026quot;Consecutive Double\u0026quot; \u0026quot;Consecutive Double\u0026quot; ... ## $ MatchPos : int 33 33 33 33 33 33 33 33 33 33 ... ## $ Annotation: chr \u0026quot;CDS\u0026quot; \u0026quot;CDS\u0026quot; \u0026quot;CDS\u0026quot; \u0026quot;CDS\u0026quot; ... ## $ meanCS : num 1.0546 0.9534 0.839 0.4866 -0.0992 ... ## $ pVal : num 0.00993 0.81008 0.02679 0.07028 0.172 ... ## $ log10pVal : num 2.0029 0.0915 1.572 1.1532 0.7645 ... ## $ DeltaCS : num 0 -0.101 -0.216 -0.568 -1.154 ... #Find the unique values for your MatchType column unique(tiling_result$MatchType) ## [1] \u0026quot;Perfect Match\u0026quot; \u0026quot;Consecutive Double\u0026quot; \u0026quot;Consecutive Triple\u0026quot; ## [4] \u0026quot;First Order\u0026quot; \u0026quot;Random Double\u0026quot; # Make MatchType a factor tiling_result$MatchType = factor( x = tiling_result$MatchType, levels = c( \u0026quot;Perfect Match\u0026quot;, \u0026quot;First Order\u0026quot;, \u0026quot;Random Double\u0026quot;, \u0026quot;Consecutive Double\u0026quot;, \u0026quot;Consecutive Triple\u0026quot; ), labels = c( \u0026quot;PM\u0026quot;, \u0026quot;SM\u0026quot;, \u0026quot;RD\u0026quot;, \u0026quot;CD\u0026quot;, \u0026quot;CT\u0026quot; ) ) Next, let’s make the basic ggplot for the tiling result, with MatchType on the x axis, DeltaCS on the y axis, and colored points by MatchType. You’ll want to use geom_jitter() rather than geom_point(), with a width of 0.2, a size of 3, and a shape of 20.\ntiling_result %\u0026gt;% #Filter out the NAs in the DeltaCS column filter(!is.na(DeltaCS)) %\u0026gt;% #Make your ggplot scatter plot here ggplot(., aes(x = MatchType, y = DeltaCS, color = MatchType)) + geom_jitter() We’ll add horizontal lines using the new function stat_summary(), which provides plotting of simple summary statistics. First, let’s look up the documentation for stat_summary().\n#What is the other way to find the help menu? ?stat_summary Let’s go ahead and use stat_summary, finding the median of each group:\ntiling_result %\u0026gt;% filter(!is.na(DeltaCS)) %\u0026gt;% ggplot(aes(x = MatchType, y = DeltaCS, color = MatchType)) + geom_jitter( # Do you notice several things are different from your plot above # and the real one in the paper? # The size of the points and how wide they spread/jitter are the most # obvious to me, so we are fixing those here. width = 0.2,size = 3,shape = 20 ) + # Add a horizontal bar at the median of each group # NEW FUNCTION!! stat_summary() provides plotting of simple summary # statistics (defined by fun (function to summarize each group)) with several # types of plots (defined by geom) stat_summary( fun = median, geom = \u0026quot;crossbar\u0026quot;, width = 0.5, color = \u0026quot;black\u0026quot; )  Next, we can scale our y axis continuously, as follows:\ntiling_result %\u0026gt;% filter(!is.na(DeltaCS)) %\u0026gt;% ggplot(aes(x = MatchType, y = DeltaCS, color = MatchType)) + geom_jitter(width = 0.2,size = 3,shape = 20) + stat_summary(fun = median,geom = \u0026quot;crossbar\u0026quot;,width = 0.5, color = \u0026quot;black\u0026quot;) + #scaling function scale_y_continuous(limits = c(-2, 0.5), breaks = c(seq(-2, 0))) ## Warning: Removed 2 rows containing non-finite values (stat_summary). ## Warning: Removed 2 rows containing missing values (geom_point). To finish up this plot, we’ll want to set the following arguments. With a partner, add these to your plot:\n title your plot “Individual crRNA” remove the x axis label set the y axis label to “delta log2(FC)” set the coordinate ratio to 7/3.5 set the colors to sanajana colors as we did before (note that this time the function has to be scale_color_manual rather than scale_fill_manual) Remove x-axis line and tick as we did before  # Your publication-ready plot here tiling_result %\u0026gt;% filter(!is.na(DeltaCS)) %\u0026gt;% ggplot(aes(x = MatchType, y = DeltaCS, color = MatchType)) + geom_jitter(width = 0.2,size = 3,shape = 20) + stat_summary(fun = median,geom = \u0026quot;crossbar\u0026quot;,width = 0.5, color = \u0026quot;black\u0026quot;) + #scaling function scale_y_continuous(limits = c(-2, 0.5), breaks = c(seq(-2, 0))) + scale_color_manual(values = sanjana_colors) + coord_fixed(ratio = 7/3.5) + # Set axis labels xlab(\u0026quot;\u0026quot;) + ylab(\u0026quot;Delta log2(FC)\u0026quot;) + ggtitle(\u0026quot;Individual crRNAs\u0026quot;) + theme_classic() + theme( axis.line.x = element_blank(), axis.ticks.x = element_blank() ) + guides(color = \u0026quot;none\u0026quot;) ## Warning: Removed 2 rows containing non-finite values (stat_summary). ## Warning: Removed 2 rows containing missing values (geom_point).   Figure 1d: Scatter plot with a smooth line Figure 1d is a panel of scatter plots with a smooth line for enrichment scores of individual crRNAs targeting different regions of the GFP transcript.\nThe processed data for individual crRNAs that target GFP is provided in data/GFPTiling_individual_full.csv. Specifically:\n Log-transformed enrichment scores are stored in meanCS The points are plotted over the GFP transcripts, and the coordinates of matching site is in MatchPos The points were colored by which quantile it falls into.  Quantile is just binning values into four bins, and dplyr has another function to determine *which quantile a row belongs to by a numeric column of your choice, and the syntax is ntile(column, number_of_bins).\nA minimal example of its usage is:\nexdf = data.frame( value = 1:10 ) exdf %\u0026gt;% mutate( split_at_median = ntile(value, 2), quantile = ntile(value, 4) ) ## value split_at_median quantile ## 1 1 1 1 ## 2 2 1 1 ## 3 3 1 1 ## 4 4 1 2 ## 5 5 1 2 ## 6 6 2 2 ## 7 7 2 3 ## 8 8 2 3 ## 9 9 2 4 ## 10 10 2 4 Please observe the figure and propose your way of reproducing the panel. The colors they used are provided in the chunk below:\ngfp_color = c(\u0026#39;#ca0020\u0026#39;,\u0026#39;#f4a582\u0026#39;,\u0026#39;#92c5de\u0026#39;,\u0026#39;#0571b0\u0026#39;) # Load data allGFP = read.csv(\u0026quot;data/GFPTiling_individual_full.csv\u0026quot;) # Use qtile() within mutate to create our data frame allGFP %\u0026gt;% filter(!is.na(meanCS)) %\u0026gt;% # Assign quartile (split into 4 proportions) by meanCS # Since we are going to color by quartile, it is preferable to use factor # than numerics mutate(qtile = as.factor(ntile(meanCS, 4))) %\u0026gt;% head(20) ## Screen GuideName Guide MatchType MatchPos Annotation ## 1 GFP crRNA001:1-27 crRNA001 Perfect Match 27 CDS ## 2 GFP crRNA002:2-28 crRNA002 Perfect Match 28 CDS ## 3 GFP crRNA003:6-32 crRNA003 Perfect Match 32 CDS ## 4 GFP crRNA004:7-33 crRNA004 Perfect Match 33 CDS ## 5 GFP crRNA005:9-35 crRNA005 Perfect Match 35 CDS ## 6 GFP crRNA006:10-36 crRNA006 Perfect Match 36 CDS ## 7 GFP crRNA007:11-37 crRNA007 Perfect Match 37 CDS ## 8 GFP crRNA008:12-38 crRNA008 Perfect Match 38 CDS ## 9 GFP crRNA009:14-40 crRNA009 Perfect Match 40 CDS ## 10 GFP crRNA010:15-41 crRNA010 Perfect Match 41 CDS ## 11 GFP crRNA011:16-42 crRNA011 Perfect Match 42 CDS ## 12 GFP crRNA012:20-46 crRNA012 Perfect Match 46 CDS ## 13 GFP crRNA013:21-47 crRNA013 Perfect Match 47 CDS ## 14 GFP crRNA014:22-48 crRNA014 Perfect Match 48 CDS ## 15 GFP crRNA015:26-52 crRNA015 Perfect Match 52 CDS ## 16 GFP crRNA016:27-53 crRNA016 Perfect Match 53 CDS ## 17 GFP crRNA017:30-56 crRNA017 Perfect Match 56 CDS ## 18 GFP crRNA018:31-57 crRNA018 Perfect Match 57 CDS ## 19 GFP crRNA019:33-59 crRNA019 Perfect Match 59 CDS ## 20 GFP crRNA020:37-63 crRNA020 Perfect Match 63 CDS ## meanCS pVal log10pVal ScaledCS qtile ## 1 0.697828662 0.037139487 1.4301641 1.08371271 3 ## 2 0.973333658 0.005305903 2.2752407 1.62662808 4 ## 3 1.166888147 0.052775054 1.2775713 2.00805023 4 ## 4 1.054580427 0.009933042 2.0029177 1.78673451 4 ## 5 0.850456714 0.161383678 0.7921404 1.38448445 4 ## 6 0.957187296 0.013888889 1.8573325 1.59480976 4 ## 7 0.985674966 0.136754065 0.8640598 1.65094810 4 ## 8 1.074104147 0.555658488 0.2551920 1.82520832 4 ## 9 -0.080430937 0.600709794 0.2213353 -0.44994042 1 ## 10 0.786329262 0.015443537 1.8112532 1.25811367 3 ## 11 -0.068862813 0.365481687 0.4371344 -0.42714406 1 ## 12 0.047882725 0.597939473 0.2233428 -0.19708308 1 ## 13 0.725672983 0.168281759 0.7739630 1.13858326 3 ## 14 0.108779029 0.434274771 0.3622354 -0.07707967 2 ## 15 -0.038672492 0.858834132 0.0660907 -0.36765044 1 ## 16 -0.056426383 0.295065651 0.5300813 -0.40263659 1 ## 17 0.132830725 0.552465793 0.2576946 -0.02968294 2 ## 18 0.009357908 0.763074183 0.1174332 -0.27300082 1 ## 19 -0.043976387 0.754415576 0.1223894 -0.37810239 1 ## 20 0.519437522 0.137494396 0.8617150 0.73217175 3  allGFP %\u0026gt;% filter(!is.na(meanCS)) %\u0026gt;% mutate(qtile = as.factor(ntile(meanCS, 4))) %\u0026gt;% # Pipe into ggplot and define the columns used for axes and color ggplot(aes(x = MatchPos, y = meanCS, color = qtile)) + # Plot a smooth line by the scatter points you provided geom_smooth( # There are multiple ways to get a line from points # Here, we use \u0026quot;locally estimated scatter plot smoothing\u0026quot; method = \u0026quot;loess\u0026quot;, # which fits a polynomial function (curve line) within a small window # whose size is defined by span span = 0.05, # The color of the smooth line color = \u0026quot;black\u0026quot;, # The size of the smooth line size = 0.5, # The color of the shaded area representing the standard error of # the smoothing method you picked fill = \u0026quot;grey77\u0026quot; )  ## `geom_smooth()` using formula \u0026#39;y ~ x\u0026#39; Then of course we can add the points, colored by their qtile scores\nallGFP %\u0026gt;% filter(!is.na(meanCS)) %\u0026gt;% mutate(qtile = as.factor(ntile(meanCS, 4))) %\u0026gt;% ggplot(aes(x = MatchPos, y = meanCS, color = qtile)) + geom_smooth(method = \u0026quot;loess\u0026quot;, span = 0.05, color = \u0026quot;black\u0026quot;, size = 0.5, fill = \u0026quot;grey77\u0026quot;) + geom_point(shape = 20) ## `geom_smooth()` using formula \u0026#39;y ~ x\u0026#39; allGFP %\u0026gt;% filter(!is.na(meanCS)) %\u0026gt;% mutate(qtile = as.factor(ntile(meanCS, 4))) %\u0026gt;% ggplot(aes(x = MatchPos, y = meanCS, color = qtile)) + geom_smooth(method = \u0026quot;loess\u0026quot;, span = 0.05, color = \u0026quot;black\u0026quot;, size = 0.5, fill = \u0026quot;grey77\u0026quot;) + geom_point(shape = 20) + # Use classic theme theme_classic() + # Remove color legend guides(color = \u0026quot;none\u0026quot;) + # Set the ticks and limits of x and y axes scale_x_continuous( limits = c(-50, 750), breaks = seq(0, 750, 100), ) + scale_y_continuous( limits = c(-1, 1.5), breaks = seq(-1, 1.5, 1), ) + # Set axis titles xlab(\u0026quot;Position in GFP transcript (nt)\u0026quot;) + ylab(\u0026quot;log2(FC)\u0026quot;) + # Set aspect ratio coord_fixed(ratio = 200/3) + # Set a customized color palette scale_color_manual(values = gfp_color)  ## `geom_smooth()` using formula \u0026#39;y ~ x\u0026#39; Many, many annotations are added here. This adds each individual box. Run the following code, and then try changing the Q1 box to say 1Q instead.\nallGFP %\u0026gt;% filter(!is.na(meanCS)) %\u0026gt;% mutate(qtile = as.factor(ntile(meanCS, 4))) %\u0026gt;% ggplot(aes(x = MatchPos, y = meanCS, color = qtile)) + geom_smooth(method = \u0026quot;loess\u0026quot;, span = 0.05, color = \u0026quot;black\u0026quot;, size = 0.5, fill = \u0026quot;grey77\u0026quot;) + geom_point(shape = 20) + # Use classic theme theme_classic() + # Remove color legend guides(color = \u0026quot;none\u0026quot;) + # Set the ticks and limits of x and y axes scale_x_continuous( limits = c(-50, 750), breaks = seq(0, 750, 100), ) + scale_y_continuous( limits = c(-1, 1.5), breaks = seq(-1, 1.5, 1), ) + # Set axis titles xlab(\u0026quot;Position in GFP transcript (nt)\u0026quot;) + ylab(\u0026quot;log2(FC)\u0026quot;) + # Set aspect ratio coord_fixed(ratio = 200/3) + # Set a customized color palette scale_color_manual(values = gfp_color) + # Extra annotations -- these are done manually here. # The authors wrote a function for this, which is the preferred way: # https://gitlab.com/sanjanalab/cas13/-/blob/master/scripts/Plot_GuideScoreDistributionPerGene.R#L140 # If you really want to fully recapitulate the figure, this is what you need. # But manually annotating one figure is pretty tedious as you see below. annotate( geom = \u0026quot;rect\u0026quot;, # xmin and xmax (and x for the text geom should be computed as a function) # This is basically the length of each exons in the transcript xmin = 0, xmax = 750, # These are fixed for the transcript plot ymin = -1, ymax = -0.8, color = \u0026quot;grey50\u0026quot;, fill = \u0026quot;lightblue\u0026quot;, alpha = 0.5 ) + annotate( # This labels the exon number geom = \u0026quot;text\u0026quot;, x = 750/2, y = -0.9, label = \u0026quot;1\u0026quot;, size = 2, color = \u0026quot;black\u0026quot; ) + annotate( # The following labels the range of each quartile geom = \u0026quot;rect\u0026quot;, # The x range is fixed xmin = -50, xmax = -10, # ymin, ymax, and y for the text geom should be computed if a function # is to be written ymin = min(allGFP$meanCS, na.rm = TRUE), ymax = quantile(allGFP$meanCS, 0.25, na.rm = TRUE), fill = gfp_color[1], alpha = 0.3 ) + annotate( geom = \u0026quot;text\u0026quot;, x = -30, y = (min(allGFP$meanCS, na.rm = TRUE) + quantile(allGFP$meanCS, 0.25, na.rm = TRUE))/2, label = \u0026quot;Q1\u0026quot;, size = 4 ) + annotate( geom = \u0026quot;rect\u0026quot;, xmin = -50, xmax = -10, ymin = quantile(allGFP$meanCS, 0.25, na.rm = TRUE), ymax = quantile(allGFP$meanCS, 0.5, na.rm = TRUE), fill = gfp_color[2], alpha = 0.3 ) + annotate( geom = \u0026quot;text\u0026quot;, x = -30, y = (quantile(allGFP$meanCS, 0.25, na.rm = TRUE) + quantile(allGFP$meanCS, 0.5, na.rm = TRUE))/2, label = \u0026quot;Q2\u0026quot;, size = 4 ) + annotate( geom = \u0026quot;rect\u0026quot;, xmin = -50, xmax = -10, ymin = quantile(allGFP$meanCS, 0.5, na.rm = TRUE), ymax = quantile(allGFP$meanCS, 0.75, na.rm = TRUE), fill = gfp_color[3], alpha = 0.3 ) + annotate( geom = \u0026quot;text\u0026quot;, x = -30, y = (quantile(allGFP$meanCS, 0.5, na.rm = TRUE) + quantile(allGFP$meanCS, 0.75, na.rm = TRUE))/2, label = \u0026quot;Q3\u0026quot;, size = 4 ) + annotate( geom = \u0026quot;rect\u0026quot;, xmin = -50, xmax = -10, ymin = quantile(allGFP$meanCS, 0.75, na.rm = TRUE), ymax = max(allGFP$meanCS, na.rm = TRUE), fill = gfp_color[4], alpha = 0.3 ) + annotate( geom = \u0026quot;text\u0026quot;, x = -30, y = (quantile(allGFP$meanCS, 0.75, na.rm = TRUE) + max(allGFP$meanCS, na.rm = TRUE))/2, label = \u0026quot;Q4\u0026quot;, size = 4 ) ## `geom_smooth()` using formula \u0026#39;y ~ x\u0026#39;  ","date":1657756800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657833389,"objectID":"33f62a5fc56f261552c309c74e02b1eb","permalink":"https://nyusurp.github.io/2022/07/14/reproducing-visualization-in-publications/","publishdate":"2022-07-14T00:00:00Z","relpermalink":"/2022/07/14/reproducing-visualization-in-publications/","section":"handout","summary":"Quick recap/practice To warm up, we’re going to use one of Cassandra’s data sets, which has chromosome positions and z-scores. We’ll do each of these exercises together.\n# Load in the data BSAResults = read.","tags":[],"title":"Reproducing Visualization in Publications","type":"handout"},{"authors":["Yen-Chung Chen"],"categories":["Handout"],"content":" Function cheatsheet Base R mean() sum() head() tail() length() dim() as.numeric() as.character() typeof() unique() - NEW - prints each categorical value only once (so the unique of c(1,2,2,4,5,5,5,8) would be 1,2,4,5,8)  Dplyr filter() group_by() summarize() na.omit() mutate() - NEW - adds a new column based on the arguments within transmute() - NEW - adds a new column based on the arguments within and then selects only that column  Ggplot2 ggplot() aes() geom_point() geom_density() geom_count() geom_bar() ggtitle() xlab() ylab() geom_hline() - NEW - makes a horizontal line at the y intercept specified geom_vline()- NEW - makes a vertical line at the x intercept specified ylim() - NEW - takes in two numbers as the limits for the y axis xlim() - NEW - takes in two numbers as the limits for the x axis   Advanced cheatsheets  Master repository by RStudio Base R (Mostly) dplyr dplyr: Transformation ggplot2 tidyr   Quick recap penguins \u0026lt;- read.csv(\u0026quot;penguins.csv\u0026quot;) #We can use dplyr\u0026#39;s piping to filter by specific variables penguins %\u0026gt;% filter(species == \u0026quot;Adelie\u0026quot;) %\u0026gt;% head() ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18.0 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## sex year ## 1 male 2007 ## 2 female 2007 ## 3 female 2007 ## 4 \u0026lt;NA\u0026gt; 2007 ## 5 female 2007 ## 6 male 2007 penguins %\u0026gt;% filter(species == \u0026quot;Adelie\u0026quot;) %\u0026gt;% ggplot(aes(x = sex)) + geom_bar() #We can also get summary statistics using summarize penguins %\u0026gt;% na.omit() %\u0026gt;% group_by(species, sex) %\u0026gt;% summarize(bill_length_mean = mean(bill_length_mm))  ## `summarise()` has grouped output by \u0026#39;species\u0026#39;. You can override using the ## `.groups` argument. ## # A tibble: 6 × 3 ## # Groups: species [3] ## species sex bill_length_mean ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; ## 1 Adelie female 37.3 ## 2 Adelie male 40.4 ## 3 Chinstrap female 46.6 ## 4 Chinstrap male 51.1 ## 5 Gentoo female 45.6 ## 6 Gentoo male 49.5 #And then pipe this into a plot penguins %\u0026gt;% na.omit() %\u0026gt;% group_by(species, sex) %\u0026gt;% summarize(bill_length_mean = mean(bill_length_mm)) %\u0026gt;% ggplot(aes(x = sex, y = bill_length_mean, color = species)) + geom_point() ## `summarise()` has grouped output by \u0026#39;species\u0026#39;. You can override using the ## `.groups` argument.  Review Practice #### Practice dataset # Load the Hollywood data # Data courtesy: InformationIsBeautiful.net # Data source: https://public.tableau.com/s/resources?qt-overview_resources=1#qt-overview_resources hollywood = read.csv(\u0026quot;hollywood.csv\u0026quot;) #### What is in the dataset? Use head() or str() #### Piping into plots hollywood %\u0026gt;% ## How do we remove rows with missing profitability or audience score? filter(!is.na(Profitability), !is.na(Audience_score)) %\u0026gt;% ## How do we keep only movies that are comedies filter(Genre == \u0026quot;Comedy\u0026quot;) %\u0026gt;% ## How do we make a scatter plot that: # 1. The x-axis is score on Rotten Tomatoes # 2. The y-axis is how profitable a movie is ggplot(., aes(x = Audience_score, y = Profitability, color = Lead_Studio)) + geom_point() ## Finally, how do we color each point by the lead studio that made the movie  Line Plots While scatter plot is very useful, line plot is sometimes useful to connect the dots and represent a trend. In ggplot2, it is usually achieved with geom_line().\n# When you have many data, scatter plots can be difficult for finding trends hollywood %\u0026gt;% na.omit() %\u0026gt;% ggplot(., aes(x = Year, y = Profitability, color = Genre)) + geom_jitter() # Let\u0026#39;s first get the average profitability per year per genre hollywood %\u0026gt;% group_by(Genre, Year) %\u0026gt;% # Since we are going to average, missing data will mess up the output. # We are dropping them for the time being. na.omit() %\u0026gt;% # Use summarize to get the average per group defined above summarize(avg_profit = mean(Profitability)) %\u0026gt;% # Pipe the summary data frame to ggplot ggplot(., aes(x = Year, y = avg_profit, color = Genre)) + geom_line() ## `summarise()` has grouped output by \u0026#39;Genre\u0026#39;. You can override using the ## `.groups` argument.  Pivoting using pivot_longer() Oftentimes, we want to plot different data together in one plot (if they are on a same scale). For example, check example_two_color.png in the folder. How would you make a plot like this?\nOne (hopefully) straightforward way of making this kind of plot is to have a column that contains the kind of scores, so you can do something like aes(color = kind_of_score), while at the same time have another column that keeps both the score from audiences and from Rotten Tomatoes to allow aes(x = review_score).\ntidyr provides a simple way to do this. The function that does this is pivot_longer(), and the minimal thing that you need to know before using it is which columns contain the scores that you want to store into the same column.\n# Examine the original data.frame head(hollywood) ## Film Genre Lead_Studio Audience_score Profitability ## 1 27 Dresses Comedy Fox 71 5.3436218 ## 2 (500) Days of Summer Comedy Fox 81 8.0960000 ## 3 A Dangerous Method Drama Independent 89 0.4486447 ## 4 A Serious Man Drama Universal 64 4.3828571 ## 5 Across the Universe Romance Independent 84 0.6526032 ## 6 Beginners Comedy Independent 80 4.4718750 ## Rotten_Tomatoes Worldwide_Gross Year ## 1 40 160.308654 2008 ## 2 87 60.720000 2009 ## 3 79 8.972895 2011 ## 4 89 30.680000 2009 ## 5 54 29.367143 2007 ## 6 84 14.310000 2011 # Say we want to store audience_score and rotten_tomatoes into the same column # assign the new data.frame into another object to make comparison easier long_hollywood = hollywood %\u0026gt;% pivot_longer(cols = c(Audience_score, Rotten_Tomatoes)) head(long_hollywood) ## # A tibble: 6 × 8 ## Film Genre Lead_Studio Profitability Worldwide_Gross Year name value ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; ## 1 27 Dresses Come… Fox 5.34 160. 2008 Audi… 71 ## 2 27 Dresses Come… Fox 5.34 160. 2008 Rott… 40 ## 3 (500) Days … Come… Fox 8.10 60.7 2009 Audi… 81 ## 4 (500) Days … Come… Fox 8.10 60.7 2009 Rott… 87 ## 5 A Dangerous… Drama Independent 0.449 8.97 2011 Audi… 89 ## 6 A Dangerous… Drama Independent 0.449 8.97 2011 Rott… 79 Do you still see either Audience_score or Rotten_Tomatoes?\nSometimes, naming columns name and value could be confusing for the future you, and you are likely to be able to come up with better names.\npivot_longer() provides such arguments, so let’s ?pivot_longer or help(pivot_longer) and find out which arguments provide this function.\n# Let\u0026#39;s name the score column \u0026quot;score\u0026quot; # while the source of review column \u0026quot;score_type\u0026quot; long_hollywood = hollywood %\u0026gt;% pivot_longer( cols = c(Audience_score, Rotten_Tomatoes), names_to = \u0026quot;score_type\u0026quot;, values_to = \u0026quot;score\u0026quot; ) head(long_hollywood) ## # A tibble: 6 × 8 ## Film Genre Lead_Studio Profitability Worldwide_Gross Year score_type score ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; ## 1 27 Dre… Come… Fox 5.34 160. 2008 Audience_… 71 ## 2 27 Dre… Come… Fox 5.34 160. 2008 Rotten_To… 40 ## 3 (500) … Come… Fox 8.10 60.7 2009 Audience_… 81 ## 4 (500) … Come… Fox 8.10 60.7 2009 Rotten_To… 87 ## 5 A Dang… Drama Independent 0.449 8.97 2011 Audience_… 89 ## 6 A Dang… Drama Independent 0.449 8.97 2011 Rotten_To… 79  Practice You will find in the folder rnaseq_for_heatmap.csv.\nWith your partner,\nExamine what the data is about: What is each row and column?\n Use pivot_longer() to store the z-scores of every gene in a column, and the gene symbols in another.\n Let’s name the value column z_score and the name column gene.\n  Assign the pivoted data.frame to a new object.\nrnaseq = read.csv(\u0026quot;rnaseq_for_heatmap.csv\u0026quot;) # You don\u0026#39;t really want to pivot the sample column, so please set # cols = -sample. This would pivot all other columns except for sample. rnaseq_plot = rnaseq %\u0026gt;% pivot_longer( cols = -sample, names_to = \u0026quot;gene\u0026quot;, values_to = \u0026quot;z_score\u0026quot; ) head(rnaseq_plot) ## # A tibble: 6 × 3 ## sample gene z_score ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; ## 1 A_Brachial Aldh1a2 0.0398 ## 2 A_Brachial Runx1 0.112 ## 3 A_Brachial Tacr3 0.666 ## 4 A_Brachial Etv4 0.222 ## 5 A_Brachial Dio3 0.759 ## 6 A_Brachial Smug1 0.827  Heatmaps Another popular visualization to show differences and trend is heatmaps. In a heatmap, every data point is presented as a block, and the value to be compared is represented by the color of the block.\nThis can be done with geom_tile()\n# Say we want to see if the average z-score for each chromosome # for both bulk and parent # We can first group by chromosomes and sample type rnaseq_plot %\u0026gt;% ggplot(., aes(x = sample, y = gene, fill = z_score)) + geom_tile() You might find the default ggplot2 coloring less than ideal. If that’s the case, you can turn to scale_* family of functions.\nIn our case, we want to change a gradient that is used to fill, so the function would be scale_fill_gradient().\nThe function takes two colors, low and high. You can refer to colors by their names or by hex codes.\nYou can find a list of named colors in R here.\nrnaseq_plot %\u0026gt;% ggplot(., aes(x = sample, y = gene, fill = z_score)) + geom_tile() + scale_fill_gradient(low = \u0026quot;green\u0026quot;, high = \u0026quot;magenta\u0026quot;)  Factors This RNA-Seq dataset is originally from Figure 5B of this article, but it currently looks very messy and different from the figure. What is happening?\n# The row order that is defined in a data.frame fruits = data.frame( type = c(\u0026quot;banana\u0026quot;, \u0026quot;apple\u0026quot;, \u0026quot;citrus\u0026quot;), price = c(5, 1, 3) ) # Will not be respected even in a very simple plot # Check the x-axis -- it\u0026#39;s alphabetically ordered fruits %\u0026gt;% qplot(data = ., x = type, y = price) To tell ggplot2 the order we want, we must let it know its a categorical variable with an order. This is called a factor in R.\n# We can make a factor from a character vector using factor(). fruits$factor_type = factor( # Give it the vector you want to convert x = fruits$type, # A level is a category # the order you used for levels will be honored by ggplot2 levels = c(\u0026quot;banana\u0026quot;, \u0026quot;apple\u0026quot;, \u0026quot;citrus\u0026quot;) ) # Let\u0026#39;s try the same plot again fruits %\u0026gt;% qplot(data = ., x = factor_type, y = price) Practice: Ordering gene symbols with factors We can do the same for the gene column in rnaseq_plot. You can find a list of genes in the folder in gene_order.txt. Let’s load it into R with readLines(), which would load every line of the file as an element of a vector.\n# Load gene list gene_order = readLines(\u0026quot;gene_order.txt\u0026quot;) Then, we are going to make rnaseq_plot$gene a factor, and use the order of genes we just loaded above to define its levels.\n# Use factor() to convert rnaseq_plot$gene into a factor # define the order with gene_order (loaded above) # and assign it into a new column (gene_ordered) rnaseq_plot$gene_ordered = factor( x = rnaseq_plot$gene, levels = gene_order ) Now that the genes are ordered as the article, let’s plot the heatmap again. This time, use gene_ordered instead of gene as the y-axis.\nrnaseq_plot %\u0026gt;% ggplot(., aes(x = sample, y = gene_ordered, fill = z_score)) + geom_tile() + scale_fill_gradient(low = \u0026quot;green\u0026quot;, high = \u0026quot;magenta\u0026quot;)   Practice Exercises Today we’re going to use one of Cassandra’s data sets, which has chromosome positions and z-scores.\nBSAResults = read.csv(\u0026quot;BSAResults.csv\u0026quot;) # Filter for Chromosome II using dplyr\u0026#39;s filter() function BSAResults %\u0026gt;% filter(CHROM == \u0026quot;II\u0026quot;) %\u0026gt;% head() ## X CHROM POS Bulk Parent Interaction ## 1 result.11000 II 100153 -0.18330726 -0.06467321 0.19943965 ## 2 result.21000 II 100367 -0.18800155 -0.29128447 0.28590390 ## 3 result.31000 II 100413 -0.32764216 -0.30312559 0.52362311 ## 4 result.41000 II 100878 0.02040887 0.11852673 -0.16398910 ## 5 result.51000 II 101103 -0.13385976 -0.01003441 -0.01602947 ## 6 result.6432 II 101289 -0.25282081 0.08171578 0.21342401 # Plot a scatter plot of the Bulk with x-axis being POS and y-axis being Bulk values BSAResults %\u0026gt;% filter(CHROM == \u0026quot;II\u0026quot;) %\u0026gt;% ggplot(., aes(x = POS, y = Bulk)) + geom_point() # If we want plot Bulk, Interaction, and Parent for Chr II at once, we need to pivot the data to long format. How do we do so? BSAResults %\u0026gt;% filter(CHROM == \u0026quot;II\u0026quot;) %\u0026gt;% pivot_longer(c(\u0026quot;Bulk\u0026quot;, \u0026quot;Parent\u0026quot;, \u0026quot;Interaction\u0026quot;))  ## # A tibble: 10,710 × 5 ## X CHROM POS name value ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; ## 1 result.11000 II 100153 Bulk -0.183 ## 2 result.11000 II 100153 Parent -0.0647 ## 3 result.11000 II 100153 Interaction 0.199 ## 4 result.21000 II 100367 Bulk -0.188 ## 5 result.21000 II 100367 Parent -0.291 ## 6 result.21000 II 100367 Interaction 0.286 ## 7 result.31000 II 100413 Bulk -0.328 ## 8 result.31000 II 100413 Parent -0.303 ## 9 result.31000 II 100413 Interaction 0.524 ## 10 result.41000 II 100878 Bulk 0.0204 ## # … with 10,700 more rows # Then to plot, we can separate our data by \u0026quot;name\u0026quot; BSAResults %\u0026gt;% filter(CHROM == \u0026quot;II\u0026quot;) %\u0026gt;% pivot_longer(c(\u0026quot;Bulk\u0026quot;, \u0026quot;Parent\u0026quot;, \u0026quot;Interaction\u0026quot;)) %\u0026gt;% ggplot(aes(x = POS, y = value, color = name)) + geom_point() # There\u0026#39;s a more interesting thing happening on Chr VIII. Filter for this next BSAResults %\u0026gt;% filter(CHROM == \u0026quot;VIII\u0026quot;) %\u0026gt;% pivot_longer(c(\u0026quot;Bulk\u0026quot;, \u0026quot;Parent\u0026quot;, \u0026quot;Interaction\u0026quot;)) %\u0026gt;% ggplot(aes(x = POS, y = value, color = name)) + geom_point() #There are a lot of points. Change the opacity of these points BSAResults %\u0026gt;% filter(CHROM == \u0026quot;VIII\u0026quot;) %\u0026gt;% pivot_longer(c(\u0026quot;Bulk\u0026quot;, \u0026quot;Parent\u0026quot;, \u0026quot;Interaction\u0026quot;)) %\u0026gt;% ggplot(aes(x = POS, y = value, color = name)) + geom_point(alpha = 0.5) # We now want to change the names to reflect what the value actually is. Add labels to the plot BSAResults %\u0026gt;% filter(CHROM == \u0026quot;VIII\u0026quot;) %\u0026gt;% pivot_longer(c(\u0026quot;Bulk\u0026quot;, \u0026quot;Parent\u0026quot;, \u0026quot;Interaction\u0026quot;)) %\u0026gt;% ggplot(aes(x = POS, y = value, color = name)) + geom_point(alpha = 0.5) + ggtitle(\u0026quot;Effects of GLM\u0026quot;) + ylab(\u0026quot;Z score\u0026quot;) + xlab(\u0026quot;Position\u0026quot;) # A different theme might be better. Let\u0026#39;s use theme_classic() BSAResults %\u0026gt;% filter(CHROM == \u0026quot;VIII\u0026quot;) %\u0026gt;% pivot_longer(c(\u0026quot;Bulk\u0026quot;, \u0026quot;Parent\u0026quot;, \u0026quot;Interaction\u0026quot;)) %\u0026gt;% ggplot(aes(x = POS, y = value, color = name)) + geom_point(alpha = 0.5) + ggtitle(\u0026quot;Effects of GLM\u0026quot;) + ylab(\u0026quot;Z score\u0026quot;) + xlab(\u0026quot;Position\u0026quot;) + theme_classic() # Faceting BSAResults %\u0026gt;% pivot_longer(c(\u0026quot;Bulk\u0026quot;, \u0026quot;Parent\u0026quot;, \u0026quot;Interaction\u0026quot;)) %\u0026gt;% ggplot(aes(x = POS, y = value, color = name)) + geom_point(alpha = 0.5) + ggtitle(\u0026quot;Effects of GLM\u0026quot;) + ylab(\u0026quot;Z score\u0026quot;) + xlab(\u0026quot;Position\u0026quot;) + facet_grid(~CHROM) #There are some weird values, but because these are z-scores, we know most of the data should be within +/- 2 unless significat. We can change our limits to reflect this and see actual trends BSAResults %\u0026gt;% pivot_longer(c(\u0026quot;Bulk\u0026quot;, \u0026quot;Parent\u0026quot;, \u0026quot;Interaction\u0026quot;)) %\u0026gt;% ggplot(aes(x = POS, y = value, color = name)) + geom_line(alpha = 0.5) + ggtitle(\u0026quot;Effects of GLM\u0026quot;) + ylab(\u0026quot;Z score\u0026quot;) + xlab(\u0026quot;Position\u0026quot;)+ ylim(-5,5) + facet_grid(~CHROM, scales = \u0026quot;free\u0026quot;, space = \u0026quot;free_x\u0026quot;)  Coming up: Sanjana Lab Data  Github: https://gitlab.com/sanjanalab/cas13 Paper: https://www.nature.com/articles/s41587-020-0456-9#Sec1 Figure 1: https://www.nature.com/articles/s41587-020-0456-9/figures/1   ","date":1657584000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657647955,"objectID":"42bcf540744e141a50fade66862035d9","permalink":"https://nyusurp.github.io/2022/07/12/pivoting-and-ggplot2/","publishdate":"2022-07-12T00:00:00Z","relpermalink":"/2022/07/12/pivoting-and-ggplot2/","section":"handout","summary":"Function cheatsheet Base R mean() sum() head() tail() length() dim() as.numeric() as.character() typeof() unique() - NEW - prints each categorical value only once (so the unique of c(1,2,2,4,5,5,5,8) would be 1,2,4,5,8)  Dplyr filter() group_by() summarize() na.","tags":[],"title":"Pivoting and ggplot2","type":"handout"},{"authors":["Cassandra Buzby"],"categories":["Handout"],"content":" Review A quick review before we get into more complicated exercises:\n#Load in your data penguins \u0026lt;- read.csv(\u0026quot;penguins.csv\u0026quot;) #Look at the column names and types of your data using str() str(penguins) ## \u0026#39;data.frame\u0026#39;: 344 obs. of 8 variables: ## $ species : chr \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; ... ## $ island : chr \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; ... ## $ bill_length_mm : num 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ... ## $ bill_depth_mm : num 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ... ## $ flipper_length_mm: int 181 186 195 NA 193 190 181 195 193 190 ... ## $ body_mass_g : int 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ... ## $ sex : chr \u0026quot;male\u0026quot; \u0026quot;female\u0026quot; \u0026quot;female\u0026quot; NA ... ## $ year : int 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ... #Make a scatter plot of *body mass* and *bill depth* ggplot(penguins, aes(x = body_mass_g, y = bill_depth_mm)) + geom_point() ## Warning: Removed 2 rows containing missing values (geom_point). #Make a density plot of body mass with a fill color changing by sex and a transparency of 0.4 ggplot(penguins, aes(x = body_mass_g, fill = sex)) + geom_density(alpha = 0.4) ## Warning: Removed 2 rows containing non-finite values (stat_density). #Name the density plot above using ggtitle() ggplot(penguins, aes(x = body_mass_g, fill = sex)) + geom_density(alpha = 0.4) + ggtitle(\u0026quot;Body Mass by Sex\u0026quot;) ## Warning: Removed 2 rows containing non-finite values (stat_density). Practice Exercise With a partner, let’s make a scatter plot and two density plots of two numeric variables; make one scatter plot looking at the correlation between the two, and then a density plot for each variable that you choose. Color based on a categorical variable.\n# Use head() or str() to find the variables that are numeric str(penguins) ## \u0026#39;data.frame\u0026#39;: 344 obs. of 8 variables: ## $ species : chr \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; ... ## $ island : chr \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; ... ## $ bill_length_mm : num 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ... ## $ bill_depth_mm : num 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ... ## $ flipper_length_mm: int 181 186 195 NA 193 190 181 195 193 190 ... ## $ body_mass_g : int 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ... ## $ sex : chr \u0026quot;male\u0026quot; \u0026quot;female\u0026quot; \u0026quot;female\u0026quot; NA ... ## $ year : int 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ... # Make a scatter plot of the two variables using geom_point() # Add a color to separate the categorical variable penguins %\u0026gt;% ggplot(., aes(x = bill_length_mm, y = body_mass_g, color = island)) + geom_point() + # Add axis labels and a title to your plot xlab(\u0026quot;Bill Length (mm)\u0026quot;) + ylab(\u0026quot;Body Mass (g)\u0026quot;) + ggtitle(\u0026quot;Does a heavier penguin have a longer bill?\u0026quot;) ## Warning: Removed 2 rows containing missing values (geom_point). #Make a density plot using geom_density() penguins %\u0026gt;% ggplot(., aes(x = bill_length_mm, color = island)) + geom_density() + # Add axis labels and a title to your plot using ggtitle(), xlab(), and ylab() xlab(\u0026quot;Bill Legnth (mm)\u0026quot;) + ylab(\u0026quot;Density\u0026quot;) + ggtitle(\u0026quot;Density distribution\u0026quot;) ## Warning: Removed 2 rows containing non-finite values (stat_density). # Share with the class which variables you chose and what your plots looked like   Using Dplyr to pipe into plotting So far we’ve included into ggplot() the arguments for data and columns, but we can also use dplyr to pipe. In dplyr, the argument being used is often referred to as ‘.’, so using this can allow you to substitute based on your other pipeline arguments.\npenguins %\u0026gt;% ggplot(data = .,aes(x = body_mass_g, color = species)) + geom_density(size = 2) ## Warning: Removed 2 rows containing non-finite values (stat_density). penguins %\u0026gt;% filter(species == \u0026quot;Adelie\u0026quot;) %\u0026gt;% ggplot(data = .,aes(x = body_mass_g, color = species)) + geom_density(size = 2) ## Warning: Removed 1 rows containing non-finite values (stat_density). Omitting NAs We can also use the dplyr function na.omit() to remove the NAs in our dataset before plotting.\n#Original graph penguins %\u0026gt;% ggplot(., aes(x = body_mass_g, fill = sex)) + geom_density(alpha = 0.4) + ggtitle(\u0026quot;Body Mass by Sex\u0026quot;) ## Warning: Removed 2 rows containing non-finite values (stat_density). #New graph penguins %\u0026gt;% na.omit() %\u0026gt;% ggplot(., aes(body_mass_g, fill = sex)) + geom_density(alpha = 0.4) + ggtitle(\u0026quot;Body Mass by Sex\u0026quot;)  Practice # Using piping, filter to only the female Adelie penguins and plot their bill length vs bill depth #Color this plot by island penguins %\u0026gt;% filter(species == \u0026quot;Adelie\u0026quot;, sex == \u0026quot;female\u0026quot;) %\u0026gt;% ggplot(., aes(x = bill_length_mm, y = bill_depth_mm, color = island)) + geom_point() # Change the size to be 3 and the transparency of your points to 0.5 penguins %\u0026gt;% filter(species == \u0026quot;Adelie\u0026quot;, sex == \u0026quot;female\u0026quot;) %\u0026gt;% ggplot(., aes(x = bill_length_mm, y = bill_depth_mm, color = island)) + geom_point(size = 3, alpha = 0.5) # Label your plot and include a title penguins %\u0026gt;% filter(species == \u0026quot;Adelie\u0026quot;, sex == \u0026quot;female\u0026quot;) %\u0026gt;% ggplot(., aes(x = bill_length_mm, y = bill_depth_mm, color = island)) + geom_point(size = 3, alpha = 0.5) + xlab(\u0026quot;Bill Length (mm)\u0026quot;) + ylab(\u0026quot;Bill Depth (mm)\u0026quot;) + ggtitle(\u0026quot;I ♥ Adelie Penguins\u0026quot;)   Bar Plots We’ve mostly looked at numeric data; but what about using categorical data on our x or y axis? Bar plots are one way to look at this, and they have multiple functions for a bar-like graph. Here we’ll go through a few\nCounts #To count the number of individuals penguins %\u0026gt;% ggplot(., aes(x = species)) + geom_bar() #Adding in color to separate by sex penguins %\u0026gt;% ggplot(., aes(x = species, fill = sex)) + geom_bar() #Changing the position to penguins %\u0026gt;% na.omit() %\u0026gt;% ggplot(., aes(x = species, fill = sex)) + geom_bar(position = \u0026quot;dodge\u0026quot;)  Values Instead of the automatic counts that we get in geom_bar(), we can use geom_col() to produce columns that represent the measure of choice. Keep in mind that bar graphs of either type will start at 0, and so the scale might not be a good representation of differences. Since it is possible to change the y axis, keep in mind that you should almost NEVER do this on a bar plot because it looks misleading and enhances the differences in disproportionate ways. Other plots are better suited.\npenguins %\u0026gt;% na.omit() %\u0026gt;% group_by(species) %\u0026gt;% summarize(mean_bill = mean(bill_length_mm)) %\u0026gt;% ggplot(., aes(x = species, y = mean_bill)) + geom_col() penguins %\u0026gt;% na.omit() %\u0026gt;% group_by(year, species) %\u0026gt;% summarize(mean = mean(bill_length_mm)) %\u0026gt;% ggplot(., aes(x = year, fill = species, y = mean)) + geom_col(position = \u0026quot;dodge\u0026quot;) ## `summarise()` has grouped output by \u0026#39;year\u0026#39;. You can override using the ## `.groups` argument.  Practice Try plotting the number of penguins on each island with a fill color by sex.\n#Use geom_bar() to plot the counts penguins %\u0026gt;% na.omit() %\u0026gt;% ggplot(., aes(x = island, fill = sex)) + geom_bar(position = \u0026quot;dodge\u0026quot;) Next, plot the mean flipper length of each species, colored by sex\n#Find the average flipper length by grouping by species and sex, then summarizing penguins %\u0026gt;% group_by(species, sex) %\u0026gt;% na.omit() %\u0026gt;% summarize(mean_flipper_length = mean(flipper_length_mm)) %\u0026gt;% #Use geom_col() to plot the average flipper length ggplot(., aes( x = species, y = mean_flipper_length, fill = sex)) + geom_col(position = \u0026quot;dodge\u0026quot;) ## `summarise()` has grouped output by \u0026#39;species\u0026#39;. You can override using the ## `.groups` argument.   Boxplots We often want to plot the statistics of our graphs, and box plots are one easy way to show the quantiles without doing a ton of work on adding error bars (which have more settings to include). The function is geom_boxplot().\n#The basic plot structure penguins %\u0026gt;% ggplot(., aes(x = species, y = flipper_length_mm)) + geom_boxplot() ## Warning: Removed 2 rows containing non-finite values (stat_boxplot). #Can you add in color by species? What happens if you color by sex? penguins %\u0026gt;% ggplot(., aes(x = species, y = flipper_length_mm, color = species)) + geom_boxplot() ## Warning: Removed 2 rows containing non-finite values (stat_boxplot). penguins %\u0026gt;% ggplot(., aes(x = species, y = flipper_length_mm, color = sex)) + geom_boxplot() ## Warning: Removed 2 rows containing non-finite values (stat_boxplot). Practice Change the above graph to remove NAs.\npenguins %\u0026gt;% na.omit() %\u0026gt;% ggplot(., aes(x = species, y = flipper_length_mm, color = sex)) + geom_boxplot() Plot the bill length instead of the flipper length.\npenguins %\u0026gt;% na.omit() %\u0026gt;% ggplot(., aes(x = species, y = bill_length_mm, color = sex)) + geom_boxplot()   Exercises with new data Let’s load a new csv to practice our plotting. This is from Cassandra’s data, and includes chromosomes, positions, and reads.\nBSA_Reads \u0026lt;- read.csv(\u0026quot;BSA_Reads.csv\u0026quot;) #Look at the structure of iris to find what the options are for column names str(BSA_Reads) ## \u0026#39;data.frame\u0026#39;: 398312 obs. of 11 variables: ## $ X : int 1 2 3 4 5 6 7 8 9 10 ... ## $ CHROM : chr \u0026quot;I\u0026quot; \u0026quot;I\u0026quot; \u0026quot;I\u0026quot; \u0026quot;I\u0026quot; ... ## $ POS : int 100007 100007 100007 100007 100007 100007 100007 100007 1035 1035 ... ## $ value : int 867 590 815 160 86 189 322 43 137 99 ... ## $ allele: chr \u0026quot;ALT\u0026quot; \u0026quot;REF\u0026quot; \u0026quot;ALT\u0026quot; \u0026quot;REF\u0026quot; ... ## $ bulk : chr \u0026quot;HIGH\u0026quot; \u0026quot;LOW\u0026quot; \u0026quot;LOW\u0026quot; \u0026quot;LOW\u0026quot; ... ## $ parent: chr \u0026quot;Wine\u0026quot; \u0026quot;Oak\u0026quot; \u0026quot;Wine\u0026quot; \u0026quot;Wine\u0026quot; ... ## $ REF : chr \u0026quot;AT\u0026quot; \u0026quot;AT\u0026quot; \u0026quot;AT\u0026quot; \u0026quot;AT\u0026quot; ... ## $ Wine : chr \u0026quot;A\u0026quot; \u0026quot;A\u0026quot; \u0026quot;A\u0026quot; \u0026quot;A\u0026quot; ... ## $ Oak : chr NA NA NA NA ... ## $ Type : chr \u0026quot;Wine\u0026quot; \u0026quot;Wine\u0026quot; \u0026quot;Wine\u0026quot; \u0026quot;Wine\u0026quot; ... #What is the distribution of values? Use geom_density() BSA_Reads %\u0026gt;% ggplot(., aes(x = value)) + geom_density() # How does the distribution differ with respect to parent? Use geom_density() but color by parent. BSA_Reads %\u0026gt;% ggplot(., aes(x = value, color = parent)) + geom_density() Let’s look at the average number of reads (value) for each bulk, colored by parent\n# First, group by your bulk and parent BSA_Reads %\u0026gt;% group_by(bulk, parent) %\u0026gt;% #Next, use summarize to find the mean of the value summarize(avg_value = mean(value)) %\u0026gt;% #Finally, plot using geom_col() with bulk as your x axis label, y as the mean of your reads, and a fill color of the parent ggplot(., aes(x = bulk, y = avg_value, fill = parent)) + geom_col() + xlab(\u0026quot;Bulk\u0026quot;) + ylab(\u0026quot;Mean of Reads\u0026quot;) ## `summarise()` has grouped output by \u0026#39;bulk\u0026#39;. You can override using the ## `.groups` argument. # Separate your plot so that the position is dodge (so that the bars are next to each other) BSA_Reads %\u0026gt;% group_by(bulk, parent) %\u0026gt;% #Next, use summarize to find the mean of the value summarize(avg_value = mean(value)) %\u0026gt;% #Finally, plot using geom_col() with bulk as your x axis label, y as the mean of your reads, and a fill color of the parent ggplot(., aes(x = bulk, y = avg_value, fill = parent)) + geom_col(position = \u0026quot;dodge\u0026quot;) + xlab(\u0026quot;Bulk\u0026quot;) + ylab(\u0026quot;Mean of Reads\u0026quot;) ## `summarise()` has grouped output by \u0026#39;bulk\u0026#39;. You can override using the ## `.groups` argument. Finally, let’s look at the average value per chromosome, and the number of reads per chromosome.\n#Use a boxplot to look at the values for each chromosome. Your x should be CHROM and y should be value. BSA_Reads %\u0026gt;% ggplot(., aes(x = CHROM, y = value)) + geom_boxplot() #Use geom_bar() for the number of entries for each chromosome. In this case you only need x to be CHROM since geom_bar() will count for you. BSA_Reads %\u0026gt;% ggplot(., aes(x = CHROM)) + geom_bar()  Bonus: Factors The graphs of chromosomes are out of order, partially because they’re characters which are ordered alphabetically. However, Roman numerals don’t follow alphabetical order, so we can instead turn this column into a factor.\nFactors have “levels” which determine their order. We can define this using factor(), just as we switched between numbers and characters.\nBSA_Reads$CHROMf \u0026lt;- factor(BSA_Reads$CHROM, levels = c(\u0026quot;I\u0026quot;, \u0026quot;II\u0026quot;, \u0026quot;III\u0026quot;, \u0026quot;IV\u0026quot;, \u0026quot;V\u0026quot;, \u0026quot;VI\u0026quot;, \u0026quot;VII\u0026quot;, \u0026quot;VIII\u0026quot;, \u0026quot;IX\u0026quot;, \u0026quot;X\u0026quot;, \u0026quot;XI\u0026quot;, \u0026quot;XII\u0026quot;, \u0026quot;XIII\u0026quot;, \u0026quot;XIV\u0026quot;, \u0026quot;XV\u0026quot;, \u0026quot;XVI\u0026quot;)) str(BSA_Reads) ## \u0026#39;data.frame\u0026#39;: 398312 obs. of 12 variables: ## $ X : int 1 2 3 4 5 6 7 8 9 10 ... ## $ CHROM : chr \u0026quot;I\u0026quot; \u0026quot;I\u0026quot; \u0026quot;I\u0026quot; \u0026quot;I\u0026quot; ... ## $ POS : int 100007 100007 100007 100007 100007 100007 100007 100007 1035 1035 ... ## $ value : int 867 590 815 160 86 189 322 43 137 99 ... ## $ allele: chr \u0026quot;ALT\u0026quot; \u0026quot;REF\u0026quot; \u0026quot;ALT\u0026quot; \u0026quot;REF\u0026quot; ... ## $ bulk : chr \u0026quot;HIGH\u0026quot; \u0026quot;LOW\u0026quot; \u0026quot;LOW\u0026quot; \u0026quot;LOW\u0026quot; ... ## $ parent: chr \u0026quot;Wine\u0026quot; \u0026quot;Oak\u0026quot; \u0026quot;Wine\u0026quot; \u0026quot;Wine\u0026quot; ... ## $ REF : chr \u0026quot;AT\u0026quot; \u0026quot;AT\u0026quot; \u0026quot;AT\u0026quot; \u0026quot;AT\u0026quot; ... ## $ Wine : chr \u0026quot;A\u0026quot; \u0026quot;A\u0026quot; \u0026quot;A\u0026quot; \u0026quot;A\u0026quot; ... ## $ Oak : chr NA NA NA NA ... ## $ Type : chr \u0026quot;Wine\u0026quot; \u0026quot;Wine\u0026quot; \u0026quot;Wine\u0026quot; \u0026quot;Wine\u0026quot; ... ## $ CHROMf: Factor w/ 16 levels \u0026quot;I\u0026quot;,\u0026quot;II\u0026quot;,\u0026quot;III\u0026quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Now, let’s plot this new variable as our x-axis.\nBSA_Reads %\u0026gt;% ggplot(., aes(x = CHROMf)) + geom_bar()  ","date":1657152000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657832287,"objectID":"b1c874a643feab8531ef1fa7654226ba","permalink":"https://nyusurp.github.io/2022/07/07/ggplot2-and-dplyr/","publishdate":"2022-07-07T00:00:00Z","relpermalink":"/2022/07/07/ggplot2-and-dplyr/","section":"handout","summary":"Review A quick review before we get into more complicated exercises:\n#Load in your data penguins \u0026lt;- read.csv(\u0026quot;penguins.csv\u0026quot;) #Look at the column names and types of your data using str() str(penguins) ## \u0026#39;data.","tags":[],"title":"ggplot2 and dplyr","type":"handout"},{"authors":["Cassandra Buzby"],"categories":["Handout"],"content":" Review A quick review before we get into more complicated exercises:\n#We can create a data frame using the c() function myplants \u0026lt;- data.frame(Plants = c(\u0026quot;Aloe\u0026quot;, \u0026quot;Pothos\u0026quot;, \u0026quot;Spider\u0026quot;, \u0026quot;ZZ\u0026quot;, \u0026quot;Snake\u0026quot;, \u0026quot;Aloe\u0026quot;, \u0026quot;Pothos\u0026quot;, \u0026quot;Spider\u0026quot;, \u0026quot;ZZ\u0026quot;, \u0026quot;Snake\u0026quot;), Growth = c(1.2, 2.2, 3.1, 1.4, 5.7, 3.4, 1.9, 2.5, 1.2, 5.3), Water = c(1,1,1,1,1,2,2,2,2,2)) #View Data using head() or str() head(myplants) ## Plants Growth Water ## 1 Aloe 1.2 1 ## 2 Pothos 2.2 1 ## 3 Spider 3.1 1 ## 4 ZZ 1.4 1 ## 5 Snake 5.7 1 ## 6 Aloe 3.4 2 #We can use square brackets and $ to select columns and rows of a data frame myplants[myplants$Growth \u0026gt; 2,] ## Plants Growth Water ## 2 Pothos 2.2 1 ## 3 Spider 3.1 1 ## 5 Snake 5.7 1 ## 6 Aloe 3.4 2 ## 8 Spider 2.5 2 ## 10 Snake 5.3 2 #We can use dplyr to filter for this same Growth myplants %\u0026gt;% filter(Growth \u0026gt; 2) ## Plants Growth Water ## 1 Pothos 2.2 1 ## 2 Spider 3.1 1 ## 3 Snake 5.7 1 ## 4 Aloe 3.4 2 ## 5 Spider 2.5 2 ## 6 Snake 5.3 2 #If we wanted to count how many elements in a vector satisfy this, #we could sum a logical. First print the logical, then find the sum # myplants$Growth \u0026gt; 2 sum(myplants$Growth \u0026gt; 2) ## [1] 6 #Using dplyr, we could use the count() function to find this same thing myplants %\u0026gt;% count(Growth \u0026gt; 2) ## Growth \u0026gt; 2 n ## 1 FALSE 4 ## 2 TRUE 6 myplants %\u0026gt;% filter(Growth \u0026gt; 2) %\u0026gt;% count() ## n ## 1 6 #If we wanted to make a new data frame for just the Pothos plants, # we could assign using the \u0026#39;\u0026lt;-\u0026#39; sign pothos_plants \u0026lt;- myplants[myplants$Plants == \u0026quot;Pothos\u0026quot;,] # Finally, if we wanted to use the qplot function to plot the data, we could do # so as follows: qplot(Plants, Growth, data = myplants, color = Water, size = I(5)) Work in pairs. Let’s answer a few questions to remind ourselves how functions, indexing, and dplyr all work:\n#Load in the dplyr library if you haven\u0026#39;t already library(dplyr) #Read in your penguins dataset penguins = read.csv(\u0026quot;penguins.csv\u0026quot;) #Using square brackets, make a new data frame for female Adelie penguins adelie_f = filter(penguins, sex == \u0026quot;Female\u0026quot;, species == \u0026quot;Adelie\u0026quot;) #Using dplyr, count how many Adelie female penguins are in each island adelie_f %\u0026gt;% count(island) ## [1] island n ## \u0026lt;0 rows\u0026gt; (or 0-length row.names) #Using dplyr, make another data frame for male Gentoo penguins gentoo_m = filter(penguins, sex == \u0026quot;Male\u0026quot;, species == \u0026quot;Gentoo\u0026quot;) #Without using dplyr, count how many Gentoo male penguins are on #the island Biscoe sum(gentoo_m$island == \u0026quot;Biscoe\u0026quot;) ## [1] 0  Ggplot2: Grammar of Graphics This package ggplot2 provides a base plotting function (qplot) as well as the function ggplot() to take in data and many (many) geoms to specify the plot. We’ve only used qplot, or quickplot, up until this point, but as your analysis becomes more specific and you start to tell the story of your data, you’ll want to customize.\nScatter Plots using geom_point() Let’s start with a scatter plot, since this is the default for qplot() with two axes.\nggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm)) + geom_point() ## Warning: Removed 2 rows containing missing values (geom_point). ggplot( data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, color = species) ) + geom_point() ## Warning: Removed 2 rows containing missing values (geom_point).   Practice #Try plotting the flipper length and body mass using geom_point(), # and then coloring points by sex penguins %\u0026gt;% ggplot(data = ., aes(x = flipper_length_mm, y = body_mass_g, color = sex)) + geom_point() ## Warning: Removed 2 rows containing missing values (geom_point). There are several other options for a ggplot that can be added in using ‘+’. These include ggtitle, xlim and ylim, labels, and themes. Below we’ll add a title and change the x and y axis labels.\n#First, we can look up one of the functions within ggplot2 called ggtitle, #which will have our labeling functions. Because these are each their own #function, we won\u0026#39;t get the information from the help menu of ggplot() on its #own, but this is where Googling the usage would be beneficial. ?ggtitle #Next let\u0026#39;s add these labels to our plot. Notice that each line ends in a \u0026#39;+\u0026#39; ggplot( data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, color = species) ) + geom_point() + ggtitle(\u0026quot;Penguin Bill vs Flipper Length\u0026quot;) + xlab(\u0026quot;Bill Length (mm)\u0026quot;) + ylab(\u0026quot;Flipper Length (mm)\u0026quot;) ## Warning: Removed 2 rows containing missing values (geom_point). Changing alpha and size Notice that the aes() argument gives us the columns that we’re using in our plot, and that we don’t have anything yet inside the function of geom_point(). Let’s look at the documentation for geom_point() to see our options.\n#How do we find the help menu? help(geom_point) #Scroll down to the \u0026quot;Aesthetics\u0026quot; section; what do you find? #Scroll down to the \u0026quot;Examples\u0026quot; section - how would you set your aesthetics to a fixed value? If we don’t specify a column for the aesthetics within geom_point(), we can set them to a fixed value. This will help us change the shape, size, color, and alpha of our plot.\n#Changing the size to larger ggplot( data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, color = species) ) + geom_point(size = 4) ## Warning: Removed 2 rows containing missing values (geom_point). #Changing the transparency (alpha) to lighter ggplot( data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, color = species) ) + geom_point(alpha = 0.5) ## Warning: Removed 2 rows containing missing values (geom_point). We can combine both of these values to make larger more transparent points on our plot by separating arguments with a comma. We can also change the shape.\nggplot( data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, color = species) ) + geom_point(size = 4, alpha = 0.5) ## Warning: Removed 2 rows containing missing values (geom_point). If we wanted all of the points to be the same color, not based on a variable, we would put this argument in the geom_point() function rather than inside aes().\nggplot( data = penguins, aes(x = bill_length_mm, y = flipper_length_mm) ) + geom_point(size = 4, alpha = 0.5, color = \u0026quot;red\u0026quot;) ## Warning: Removed 2 rows containing missing values (geom_point). If we wanted to change the shape of our points by our species column, how would we do this?\n# CHANGE THE FOLLOWING CODE to make **shape** rather than **color** vary by species. ggplot( data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, color = species) ) + geom_point(size = 4,alpha = 0.5) ## Warning: Removed 2 rows containing missing values (geom_point).  Density Plots using geom_density() Let’s say that instead of a scatter plot, you wanted to know the distributions of your numeric data. In this case, you could use the geom_density() function to plot this, but your arguments would be different since the default for your y axis will be density.\n#First define your data, then aesthetics (aes), # and finally add on your geom at the end ggplot(data = penguins, aes(x = flipper_length_mm, color = species)) + geom_density() ## Warning: Removed 2 rows containing non-finite values (stat_density).   Practice #On your own, add the title and x and y labels to your density plot. ggplot(data = penguins, aes(x = flipper_length_mm, color = species)) + geom_density() + labs(title = \u0026quot;Numeric data\u0026quot;, x = \u0026quot;Flipper Length (mm)\u0026quot;, y = \u0026quot;Density\u0026quot;) ## Warning: Removed 2 rows containing non-finite values (stat_density). # Next, see what the \u0026quot;size\u0026quot; function does if you add that to geom_density(). # Set the size to 2. ggplot(data = penguins, aes(x = flipper_length_mm, color = species)) + geom_density(size = 2) + labs(title = \u0026quot;Numeric data\u0026quot;, x = \u0026quot;Flipper Length (mm)\u0026quot;, y = \u0026quot;Density\u0026quot;) ## Warning: Removed 2 rows containing non-finite values (stat_density). Let’s instead use “fill” instead of “color” for our density plot.\n# Notice that the argument after x is fill, rather than color # (which we\u0026#39;ve used before) ggplot(data = penguins, aes(x = flipper_length_mm, fill = species)) + geom_density() ## Warning: Removed 2 rows containing non-finite values (stat_density). Next, let’s add transparency. What would we change about the following code to do this?\n#Once again, we can change the transparency of our plot ggplot(data = penguins, aes(x = flipper_length_mm, fill = species)) + geom_density() Practice Exercise With a partner, let’s make a scatter plot and two density plots of two numeric variables; make one scatter plot looking at the correlation between the two, and then a density plot for each variable that you choose. Color based on a categorical variable.\n#Use head() or str() to find the variables that are numeric str(penguins) ## \u0026#39;data.frame\u0026#39;: 344 obs. of 8 variables: ## $ species : chr \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; ... ## $ island : chr \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; ... ## $ bill_length_mm : num 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ... ## $ bill_depth_mm : num 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ... ## $ flipper_length_mm: int 181 186 195 NA 193 190 181 195 193 190 ... ## $ body_mass_g : int 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ... ## $ sex : chr \u0026quot;male\u0026quot; \u0026quot;female\u0026quot; \u0026quot;female\u0026quot; NA ... ## $ year : int 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ... #Make a scatter plot of the two variables using geom_point() penguins %\u0026gt;% ggplot(data = ., aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() ## Warning: Removed 2 rows containing missing values (geom_point). #Add a color to separate the categorical variable penguins %\u0026gt;% ggplot(data = ., aes( x = bill_length_mm, y = bill_depth_mm, color = island )) + geom_point() ## Warning: Removed 2 rows containing missing values (geom_point). #Add axis labels and a title to your plot penguins %\u0026gt;% ggplot(data = ., aes( x = bill_length_mm, y = bill_depth_mm, color = island )) + geom_point() + labs( title = \u0026quot;Bill metric correlation\u0026quot;, x = \u0026quot;Bill Length (mm)\u0026quot;, y = \u0026quot;Bill depth (mm)\u0026quot; ) ## Warning: Removed 2 rows containing missing values (geom_point). #Make a density plot using geom_density() penguins %\u0026gt;% ggplot(data = ., aes( x = bill_length_mm, )) + geom_density() ## Warning: Removed 2 rows containing non-finite values (stat_density). penguins %\u0026gt;% ggplot(data = ., aes( x = bill_depth_mm )) + geom_density() ## Warning: Removed 2 rows containing non-finite values (stat_density). #Add axis labels and a title to your plot penguins %\u0026gt;% ggplot(data = ., aes( x = bill_length_mm, )) + geom_density() + labs(main = \u0026quot;My ggplot (don\u0026#39;t name it like this)\u0026quot;, x = \u0026quot;Bill Lenth (mm)\u0026quot;) ## Warning: Removed 2 rows containing non-finite values (stat_density). #Share with the class which variables you chose and what your plots looked like   ","date":1656979200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657081885,"objectID":"346c716198dfcc4f26fd9362631c5c00","permalink":"https://nyusurp.github.io/2022/07/05/intro-ggplot/","publishdate":"2022-07-05T00:00:00Z","relpermalink":"/2022/07/05/intro-ggplot/","section":"handout","summary":"Review A quick review before we get into more complicated exercises:\n#We can create a data frame using the c() function myplants \u0026lt;- data.frame(Plants = c(\u0026quot;Aloe\u0026quot;, \u0026quot;Pothos\u0026quot;, \u0026quot;Spider\u0026quot;, \u0026quot;ZZ\u0026quot;, \u0026quot;Snake\u0026quot;, \u0026quot;Aloe\u0026quot;, \u0026quot;Pothos\u0026quot;, \u0026quot;Spider\u0026quot;, \u0026quot;ZZ\u0026quot;, \u0026quot;Snake\u0026quot;), Growth = c(1.","tags":[],"title":"Introduction to ggplot2","type":"handout"},{"authors":["Yen-Chung Chen"],"categories":["Handout"],"content":" Outline Review: Write yourself some functions\n Types: How they matter and how to avoid being bitten by them\n   Function practice: Normalizing RNA-Sequencing We will be using part of the data from a study on spinal motor neurons. You can find their full analysis scripts here.\n# Use read.delim instead of read.csv for **tab**-delimited files rawcount = read.delim(\u0026quot;BR-A-Control_counts.txt\u0026quot;) What is in the raw data?\n# Inspect the data you load! normalize_by_depth() How do we define a function that normalize a vector of counts by total counts?\nBefore you start writing. Let’s start humble and get a small proportion of the data so you can capture errors right away when you test your function.\nThe key of doing this is to have something that you can tell whether your code is doing something you want right away with test data structurally similar to the real data.\n# Take a small fraction of the data so we can test our function test_count = head(rawcount) Now, we are good to go. Let’s get the total count first!\n# What is our input? normalize_by_depth = function(input) { # How do we compute total count? # Let\u0026#39;s divide everything by the total count calculated above # Provide an output } Let’s test the function with our naked eyes.\n# Is the function doing what we expect it to do? normalize_by_depth(test_count) == 1472 + 6 + 109 + 43 ## logical(0) If everything goes as expected, let’s divide everything by total count in the function, too.\n# What is our input? normalize_by_depth = function(input) { # How do we compute total count? depth = sum(input$count) # Let\u0026#39;s divide everything by the total count calculated above # Provide an output # **Note that you would want to change your output!** return(depth) } Let’s test the revised function. What are we expecting here?\n# We are expecting the first gene to be ~0.903 after normalization # while the second gene is 0. # Let\u0026#39;s run the function on the test set and let the results print out. Let’s multiply the result by \\(10^{6}\\) (10^6) before returning it in our function.\n# What is our input? normalize_by_depth = function(input) { # How do we compute total count? depth = sum(input$count) # Let\u0026#39;s divide everything by the total count calculated above normalized_count = input$count/depth input$normalized_count = normalized_count # Provide an output return(input) } And test it again.\nNote that for the first gene, we used to getting 0.9030675 before multiplying with \\(10^{6}\\).\nnormalize_by_depth(test_count) ## id count normalized_count ## 1 ENSMUSG00000000001 1472 0.903067485 ## 2 ENSMUSG00000000003 0 0.000000000 ## 3 ENSMUSG00000000028 6 0.003680982 ## 4 ENSMUSG00000000031 109 0.066871166 ## 5 ENSMUSG00000000037 43 0.026380368 ## 6 ENSMUSG00000000049 0 0.000000000  get_tx_length() A gene model file contains the starting and ending coordinates of genes, transcripts, and exons.\nYou can get a gene model file from Ensembl.\nThey are often stored as GTF/GFF3 files, but the format is beyond the scope of what we are going to do today. If you are interested, you can find more information about GTF/GFF format here.\n# Load gene model file (pre-processed) gene_model = read.csv(\u0026quot;mouse_gene_model.csv\u0026quot;) head(gene_model) ## id start end ## 1 ENSMUSG00000102628 150956201 150958296 ## 2 ENSMUSG00000100595 150983666 150984611 ## 3 ENSMUSG00000097426 151012258 151012971 ## 4 ENSMUSG00000097426 151013347 151013531 ## 5 ENSMUSG00000104478 108344807 108347562 ## 6 ENSMUSG00000104385 6980784 6981446 How do we define a function that get us lengths for each gene?\n–\nlibrary(dplyr) ## ## Attaching package: \u0026#39;dplyr\u0026#39; ## The following objects are masked from \u0026#39;package:stats\u0026#39;: ## ## filter, lag ## The following objects are masked from \u0026#39;package:base\u0026#39;: ## ## intersect, setdiff, setequal, union # How do we compute the length of each exons? gene_model %\u0026gt;% head() %\u0026gt;% mutate(length = (end - start + 1)) ## id start end length ## 1 ENSMUSG00000102628 150956201 150958296 2096 ## 2 ENSMUSG00000100595 150983666 150984611 946 ## 3 ENSMUSG00000097426 151012258 151012971 714 ## 4 ENSMUSG00000097426 151013347 151013531 185 ## 5 ENSMUSG00000104478 108344807 108347562 2756 ## 6 ENSMUSG00000104385 6980784 6981446 663 Let’s test if the length column is correctly calculated.\n# For the first gene 150958296 - 150956201 + 1 ## [1] 2096 If it seems right, let’s get the sum of lengths per id now.\nget_tx_length = function(input) { # How do we compute the sum of all exons of a gene? tx_length = input %\u0026gt;% mutate(length = (end - start + 1)) # Group # Summarize by summation # Provide an output return(tx_length) } What does the output look like?\ngene_model %\u0026gt;% head() %\u0026gt;% get_tx_length() ## id start end length ## 1 ENSMUSG00000102628 150956201 150958296 2096 ## 2 ENSMUSG00000100595 150983666 150984611 946 ## 3 ENSMUSG00000097426 151012258 151012971 714 ## 4 ENSMUSG00000097426 151013347 151013531 185 ## 5 ENSMUSG00000104478 108344807 108347562 2756 ## 6 ENSMUSG00000104385 6980784 6981446 663 How do you independently test if the answer is correct for ENSMUSG00000097426?\n# Doing it differently with base R gene_of_interest = gene_model[gene_model$id == \u0026quot;ENSMUSG00000097426\u0026quot;, ] print(gene_of_interest) ## id start end ## 3 ENSMUSG00000097426 151012258 151012971 ## 4 ENSMUSG00000097426 151013347 151013531 gene_of_interest$length = gene_of_interest$end - gene_of_interest$start + 1 print(gene_of_interest) ## id start end length ## 3 ENSMUSG00000097426 151012258 151012971 714 ## 4 ENSMUSG00000097426 151013347 151013531 185 sum(gene_of_interest$length) ## [1] 899  How to merge data with a shared column? If we check our small count table:\nhead(rawcount) ## id count ## 1 ENSMUSG00000000001 1472 ## 2 ENSMUSG00000000003 0 ## 3 ENSMUSG00000000028 6 ## 4 ENSMUSG00000000031 109 ## 5 ENSMUSG00000000037 43 ## 6 ENSMUSG00000000049 0 and the first few rows of our gene length table:\ngene_model %\u0026gt;% head() %\u0026gt;% get_tx_length() ## id start end length ## 1 ENSMUSG00000102628 150956201 150958296 2096 ## 2 ENSMUSG00000100595 150983666 150984611 946 ## 3 ENSMUSG00000097426 151012258 151012971 714 ## 4 ENSMUSG00000097426 151013347 151013531 185 ## 5 ENSMUSG00000104478 108344807 108347562 2756 ## 6 ENSMUSG00000104385 6980784 6981446 663 You’ll see that we are almost done except that the row order are not exactly the same.\nThis can be taken care of by left_join(x, y, by = column), which is a dplyr function that **merge two data.frames (x and y) by a shared column.\n(left_ means that it keeps all the rows in x even if y does not have it.)\nLet’s see how it works. First, I’ll make a small table of gene length for testing.\ntest_gene_model = gene_model %\u0026gt;% # Only keep rows that are present in test_count filter(id %in% test_count$id) # Compute gene length with our custom function test_gene_length = test_gene_model %\u0026gt;% get_tx_length() print(test_gene_length) ## id start end length ## 1 ENSMUSG00000000037 159945768 159946244 477 ## 2 ENSMUSG00000000037 159954486 159954531 46 ## 3 ENSMUSG00000000037 159960243 159960313 71 ## 4 ENSMUSG00000000037 159961033 159961267 235 ## 5 ENSMUSG00000000037 159970260 159970348 89 ## 6 ENSMUSG00000000037 159975200 159975443 244 ## 7 ENSMUSG00000000037 159985010 159985093 84 ## 8 ENSMUSG00000000037 159992191 159992265 75 ## 9 ENSMUSG00000000037 159992605 159992679 75 ## 10 ENSMUSG00000000037 159996237 159996320 84 ## 11 ENSMUSG00000000037 159998176 159998259 84 ## 12 ENSMUSG00000000037 160004662 160004745 84 ## 13 ENSMUSG00000000037 160006153 160006236 84 ## 14 ENSMUSG00000000037 160007457 160007540 84 ## 15 ENSMUSG00000000037 160008873 160008956 84 ## 16 ENSMUSG00000000037 160010369 160010452 84 ## 17 ENSMUSG00000000037 160011673 160011756 84 ## 18 ENSMUSG00000000037 160013087 160013170 84 ## 19 ENSMUSG00000000037 160014396 160014479 84 ## 20 ENSMUSG00000000037 160017609 160017692 84 ## 21 ENSMUSG00000000037 160020476 160020753 278 ## 22 ENSMUSG00000000037 160022746 160022860 115 ## 23 ENSMUSG00000000037 160024984 160025187 204 ## 24 ENSMUSG00000000037 160026362 160026544 183 ## 25 ENSMUSG00000000037 160029253 160029363 111 ## 26 ENSMUSG00000000037 160039562 160041192 1631 ## 27 ENSMUSG00000000003 76897015 76897229 215 ## 28 ENSMUSG00000000003 76891581 76891720 140 ## 29 ENSMUSG00000000003 76888625 76888692 68 ## 30 ENSMUSG00000000003 76886503 76886613 111 ## 31 ENSMUSG00000000003 76886121 76886222 102 ## 32 ENSMUSG00000000003 76885466 76885517 52 ## 33 ENSMUSG00000000003 76881507 76881720 214 ## 34 ENSMUSG00000000001 108053204 108053462 259 ## 35 ENSMUSG00000000001 108031111 108031153 43 ## 36 ENSMUSG00000000001 108030858 108030999 142 ## 37 ENSMUSG00000000001 108025617 108025774 158 ## 38 ENSMUSG00000000001 108023079 108023207 129 ## 39 ENSMUSG00000000001 108019789 108019918 130 ## 40 ENSMUSG00000000001 108019251 108019404 154 ## 41 ENSMUSG00000000001 108016719 108016928 210 ## 42 ENSMUSG00000000001 108014596 108016632 2037 ## 43 ENSMUSG00000000031 142130566 142130647 82 ## 44 ENSMUSG00000000031 142130350 142130484 135 ## 45 ENSMUSG00000000031 142129268 142130267 1000 ## 46 ENSMUSG00000000049 108286119 108286233 115 ## 47 ENSMUSG00000000049 108286642 108286818 177 ## 48 ENSMUSG00000000049 108288125 108288221 97 ## 49 ENSMUSG00000000049 108295637 108295713 77 ## 50 ENSMUSG00000000049 108298117 108298305 189 ## 51 ENSMUSG00000000049 108299957 108300136 180 ## 52 ENSMUSG00000000049 108302821 108303018 198 ## 53 ENSMUSG00000000049 108305066 108305222 157 ## 54 ENSMUSG00000000028 18630554 18630722 169 ## 55 ENSMUSG00000000028 18630265 18630459 195 ## 56 ENSMUSG00000000028 18630055 18630114 60 ## 57 ENSMUSG00000000028 18629139 18629231 93 ## 58 ENSMUSG00000000028 18627482 18627619 138 ## 59 ENSMUSG00000000028 18626030 18626173 144 ## 60 ENSMUSG00000000028 18624132 18624187 56 ## 61 ENSMUSG00000000028 18620551 18620599 49 ## 62 ENSMUSG00000000028 18617426 18617487 62 ## 63 ENSMUSG00000000028 18616099 18616149 51 ## 64 ENSMUSG00000000028 18614575 18614694 120 ## 65 ENSMUSG00000000028 18613845 18613976 132 ## 66 ENSMUSG00000000028 18613512 18613610 99 ## 67 ENSMUSG00000000028 18611928 18612089 162 ## 68 ENSMUSG00000000028 18605680 18605818 139 ## 69 ENSMUSG00000000028 18605519 18605602 84 ## 70 ENSMUSG00000000028 18603823 18603941 119 ## 71 ENSMUSG00000000028 18603556 18603632 77 ## 72 ENSMUSG00000000028 18600646 18600712 67 ## 73 ENSMUSG00000000028 18599197 18599323 127 And… boom!\nleft_join(x = test_count, y = test_gene_length, by = \u0026quot;id\u0026quot;) ## id count start end length ## 1 ENSMUSG00000000001 1472 108053204 108053462 259 ## 2 ENSMUSG00000000001 1472 108031111 108031153 43 ## 3 ENSMUSG00000000001 1472 108030858 108030999 142 ## 4 ENSMUSG00000000001 1472 108025617 108025774 158 ## 5 ENSMUSG00000000001 1472 108023079 108023207 129 ## 6 ENSMUSG00000000001 1472 108019789 108019918 130 ## 7 ENSMUSG00000000001 1472 108019251 108019404 154 ## 8 ENSMUSG00000000001 1472 108016719 108016928 210 ## 9 ENSMUSG00000000001 1472 108014596 108016632 2037 ## 10 ENSMUSG00000000003 0 76897015 76897229 215 ## 11 ENSMUSG00000000003 0 76891581 76891720 140 ## 12 ENSMUSG00000000003 0 76888625 76888692 68 ## 13 ENSMUSG00000000003 0 76886503 76886613 111 ## 14 ENSMUSG00000000003 0 76886121 76886222 102 ## 15 ENSMUSG00000000003 0 76885466 76885517 52 ## 16 ENSMUSG00000000003 0 76881507 76881720 214 ## 17 ENSMUSG00000000028 6 18630554 18630722 169 ## 18 ENSMUSG00000000028 6 18630265 18630459 195 ## 19 ENSMUSG00000000028 6 18630055 18630114 60 ## 20 ENSMUSG00000000028 6 18629139 18629231 93 ## 21 ENSMUSG00000000028 6 18627482 18627619 138 ## 22 ENSMUSG00000000028 6 18626030 18626173 144 ## 23 ENSMUSG00000000028 6 18624132 18624187 56 ## 24 ENSMUSG00000000028 6 18620551 18620599 49 ## 25 ENSMUSG00000000028 6 18617426 18617487 62 ## 26 ENSMUSG00000000028 6 18616099 18616149 51 ## 27 ENSMUSG00000000028 6 18614575 18614694 120 ## 28 ENSMUSG00000000028 6 18613845 18613976 132 ## 29 ENSMUSG00000000028 6 18613512 18613610 99 ## 30 ENSMUSG00000000028 6 18611928 18612089 162 ## 31 ENSMUSG00000000028 6 18605680 18605818 139 ## 32 ENSMUSG00000000028 6 18605519 18605602 84 ## 33 ENSMUSG00000000028 6 18603823 18603941 119 ## 34 ENSMUSG00000000028 6 18603556 18603632 77 ## 35 ENSMUSG00000000028 6 18600646 18600712 67 ## 36 ENSMUSG00000000028 6 18599197 18599323 127 ## 37 ENSMUSG00000000031 109 142130566 142130647 82 ## 38 ENSMUSG00000000031 109 142130350 142130484 135 ## 39 ENSMUSG00000000031 109 142129268 142130267 1000 ## 40 ENSMUSG00000000037 43 159945768 159946244 477 ## 41 ENSMUSG00000000037 43 159954486 159954531 46 ## 42 ENSMUSG00000000037 43 159960243 159960313 71 ## 43 ENSMUSG00000000037 43 159961033 159961267 235 ## 44 ENSMUSG00000000037 43 159970260 159970348 89 ## 45 ENSMUSG00000000037 43 159975200 159975443 244 ## 46 ENSMUSG00000000037 43 159985010 159985093 84 ## 47 ENSMUSG00000000037 43 159992191 159992265 75 ## 48 ENSMUSG00000000037 43 159992605 159992679 75 ## 49 ENSMUSG00000000037 43 159996237 159996320 84 ## 50 ENSMUSG00000000037 43 159998176 159998259 84 ## 51 ENSMUSG00000000037 43 160004662 160004745 84 ## 52 ENSMUSG00000000037 43 160006153 160006236 84 ## 53 ENSMUSG00000000037 43 160007457 160007540 84 ## 54 ENSMUSG00000000037 43 160008873 160008956 84 ## 55 ENSMUSG00000000037 43 160010369 160010452 84 ## 56 ENSMUSG00000000037 43 160011673 160011756 84 ## 57 ENSMUSG00000000037 43 160013087 160013170 84 ## 58 ENSMUSG00000000037 43 160014396 160014479 84 ## 59 ENSMUSG00000000037 43 160017609 160017692 84 ## 60 ENSMUSG00000000037 43 160020476 160020753 278 ## 61 ENSMUSG00000000037 43 160022746 160022860 115 ## 62 ENSMUSG00000000037 43 160024984 160025187 204 ## 63 ENSMUSG00000000037 43 160026362 160026544 183 ## 64 ENSMUSG00000000037 43 160029253 160029363 111 ## 65 ENSMUSG00000000037 43 160039562 160041192 1631 ## 66 ENSMUSG00000000049 0 108286119 108286233 115 ## 67 ENSMUSG00000000049 0 108286642 108286818 177 ## 68 ENSMUSG00000000049 0 108288125 108288221 97 ## 69 ENSMUSG00000000049 0 108295637 108295713 77 ## 70 ENSMUSG00000000049 0 108298117 108298305 189 ## 71 ENSMUSG00000000049 0 108299957 108300136 180 ## 72 ENSMUSG00000000049 0 108302821 108303018 198 ## 73 ENSMUSG00000000049 0 108305066 108305222 157 This works regardless of how the rows are ordered. You can try messing up the rows and see how if it makes a difference.\n# Mess up the rows and do left_join() again. # Say we have test_count[c(1, 3, 5, 2, 4, 6), ] and # test_gene_model[c(6, 5, 4, 3, 2, 1), ]  One function to do it all You must have noticed that functions are like Russian dolls: There are always functions inside a function.\nNow that we have normalize_by_depth to generate CPM, get_tx_length to calculate gene length, and we know that left_join can merge them by ID, we can write a master function to streamline everything.\nnormalize_rnaseq = function(count, gene_model){ # 1. Normalize read counts by sequencing depth = total reads we got from a sample. # (This gives CPM) # 2. Normalize again with transcript length. # (CPM/Gene length = Transcript per million (TPM)) # 3. Make a master table containing both CPM and length per gene return(normalized_count) } Finally, let’s test it:\nnormalize_rnaseq(test_count, test_gene_model) ## Error in normalize_rnaseq(test_count, test_gene_model): could not find function \u0026quot;normalize_rnaseq\u0026quot; All your hard work pays now – you can normalize the whole thing with ease!\n# Normalize the full table with full gene model   Common pitfalls on data types characters are friendly most of the time, but… Hidden character # There\u0026#39;s a L0 masquerading as 10 in your csv! fake_num = c(\u0026quot;1\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;5\u0026quot;, \u0026quot;7\u0026quot;, \u0026quot;9\u0026quot;, \u0026quot;l0\u0026quot;) typeof(fake_num) ## [1] \u0026quot;character\u0026quot; as.numeric(fake_num) ## Warning: NAs introduced by coercion ## [1] 1 3 5 7 9 NA  Alphabetical and numerical sorting chr_vec = c(\u0026quot;5\u0026quot;, \u0026quot;8\u0026quot;, \u0026quot;6\u0026quot;, \u0026quot;10\u0026quot;, \u0026quot;7\u0026quot;, \u0026quot;9\u0026quot;) # You might not expect it to sort like this sort(chr_vec) ## [1] \u0026quot;10\u0026quot; \u0026quot;5\u0026quot; \u0026quot;6\u0026quot; \u0026quot;7\u0026quot; \u0026quot;8\u0026quot; \u0026quot;9\u0026quot; # If they are numbers, they sort differently sort(as.numeric(chr_vec)) ## [1] 5 6 7 8 9 10   Numeric type: Precision can be dangerous… 0.1 + 0.2 == 0.3 ## [1] FALSE There’s a website called https://0.30000000000000004.com/ that explains this in detail.\nBut briefly, any number that is not an integer has limited precision, and propagation of error is a thing.\n# A more robust way to compare non-integers # Define an error margin that you want to tolerate error_margin = 10^-8 # and then decide if the difference is within the margin (0.1 + 0.2) - 0.3 \u0026lt; error_margin ## [1] TRUE  Factor: Ordered categories # Categories as characters works most of the time, but... month_tbl = data.frame( month = c( \u0026quot;January\u0026quot;, \u0026quot;February\u0026quot;, \u0026quot;March\u0026quot;, \u0026quot;April\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;June\u0026quot;, \u0026quot;July\u0026quot;, \u0026quot;August\u0026quot;, \u0026quot;September\u0026quot;, \u0026quot;October\u0026quot;, \u0026quot;November\u0026quot;, \u0026quot;December\u0026quot; ), length = c( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ) ) str(month_tbl) ## \u0026#39;data.frame\u0026#39;: 12 obs. of 2 variables: ## $ month : chr \u0026quot;January\u0026quot; \u0026quot;February\u0026quot; \u0026quot;March\u0026quot; \u0026quot;April\u0026quot; ... ## $ length: num 31 28 31 30 31 30 31 31 30 31 ... Most functions that you encounter in R will sort alphabetically for characters.\nlibrary(ggplot2) month_tbl %\u0026gt;% qplot(data = ., x = month, y = length, geom = \u0026quot;point\u0026quot;) + # This adjust the axis text to make the text more visible theme(axis.text.x = element_text(size = 20, angle = 60, hjust = 1)) You won’t be able to decide the order unless you convert it to a factor.\nmonth_tbl$month = factor( month_tbl$month, # R will respect the levels you set here levels = c( \u0026quot;January\u0026quot;, \u0026quot;February\u0026quot;, \u0026quot;March\u0026quot;, \u0026quot;April\u0026quot;, \u0026quot;May\u0026quot;, \u0026quot;June\u0026quot;, \u0026quot;July\u0026quot;, \u0026quot;August\u0026quot;, \u0026quot;September\u0026quot;, \u0026quot;October\u0026quot;, \u0026quot;November\u0026quot;, \u0026quot;December\u0026quot; ) ) month_tbl %\u0026gt;% qplot(data = ., x = month, y = length, geom = \u0026quot;point\u0026quot;) + # This adjust the axis text to make the text more visible theme(axis.text.x = element_text(size = 20, angle = 60, hjust = 1)) Factors are more complicated than characters and numbers, so they could be harder to troubleshoot, but at the same time, they are very powerful especially in statistics.\nAs a rule of thumb, when you inspect your data (e.g., with str()), always ask yourself if you are having categorical variables.\nIf you do, consider converting them to factors if:\n You know they are ordinal\n When you are building statistical models with categorical variables (ANOVA et al.)\n   Date and time They have a similar issue as ordinal categories: If considered as characters, they won’t be ordered chronologically.\n# This shouldn\u0026#39;t be surprising by now random_dates = c(\u0026quot;12-25-2022\u0026quot;, \u0026quot;07-04-1989\u0026quot;, \u0026quot;01-01-2077\u0026quot;) sort(random_dates) ## [1] \u0026quot;01-01-2077\u0026quot; \u0026quot;07-04-1989\u0026quot; \u0026quot;12-25-2022\u0026quot; Unlike most categorical variables, there are usually so many dates, so it is not practical for you to assign orders manually.\nLuckily, there is a package that will take care of this for you if you tell it the format of your dates.\n# You can tell R how the date is represented to chronologically sort library(lubridate) ## ## Attaching package: \u0026#39;lubridate\u0026#39; ## The following objects are masked from \u0026#39;package:base\u0026#39;: ## ## date, intersect, setdiff, union # mdy() stands for month, day, year good_dates = mdy(random_dates) sort(good_dates) ## [1] \u0026quot;1989-07-04\u0026quot; \u0026quot;2022-12-25\u0026quot; \u0026quot;2077-01-01\u0026quot;   ","date":1656547200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1656602226,"objectID":"a989893204b916ad034f5d93be615130","permalink":"https://nyusurp.github.io/2022/06/30/functions-and-data-types/","publishdate":"2022-06-30T00:00:00Z","relpermalink":"/2022/06/30/functions-and-data-types/","section":"handout","summary":"Outline Review: Write yourself some functions\n Types: How they matter and how to avoid being bitten by them\n   Function practice: Normalizing RNA-Sequencing We will be using part of the data from a study on spinal motor neurons.","tags":[],"title":"Functions and Data Types","type":"handout"},{"authors":["Cassandra Buzby"],"categories":["Handout"],"content":" Review Let’s create our data frames again by running the following code:\nNewDataFrame \u0026lt;- data.frame(Random = c(4, 20, 10, 21, 63, 3, 14, 60, 9, 6), Index = 1:10, Categories = c(\u0026quot;Month\u0026quot;, \u0026quot;Day\u0026quot;, \u0026quot;Month\u0026quot;, \u0026quot;Day\u0026quot;, \u0026quot;Year\u0026quot;, \u0026quot;Month\u0026quot;, \u0026quot;Day\u0026quot;, \u0026quot;Year\u0026quot;, \u0026quot;Month\u0026quot;, \u0026quot;Day\u0026quot;)) Examples for plotting subsetted values If you wanted to plot only specific values, you could use these same booleans inside the functions to plot. This is going to be the basis of how we separate out values in our plots.\nlibrary(ggplot2) library(dplyr) ## ## Attaching package: \u0026#39;dplyr\u0026#39; ## The following objects are masked from \u0026#39;package:stats\u0026#39;: ## ## filter, lag ## The following objects are masked from \u0026#39;package:base\u0026#39;: ## ## intersect, setdiff, setequal, union # Plot our data frame here qplot(x = NewDataFrame$Random, y = NewDataFrame$Index) qplot(x = Random, y = Index, data = NewDataFrame) # We can change the size of our points by adding in the \u0026#39;size\u0026#39; argument qplot(x = NewDataFrame$Random, y = NewDataFrame$Index, size = 1) # Finally, we can add in coloring by a boolean logical qplot(x = NewDataFrame$Random, y = NewDataFrame$Index, color = NewDataFrame$Index \u0026gt; 5, size = 1) qplot(x = NewDataFrame$Random, y = NewDataFrame$Index, color = NewDataFrame$Categories, size = 1)  Exploring R As a reminder, we can find out more about the functions we use with the help menu, found using help() or just simply a ‘?’ in front of the function (without spaces).\nhelp(qplot) ?qplot As a reminder, there’s an option for geom. This is the type of plot that will be made, and the default is a scatter plot (so geom = “point”). You can find this in the defaults for geom.\n#Make a scatter plot qplot(x = Index, y = Random, data = NewDataFrame, geom = \u0026quot;point\u0026quot;, xlim = c(0,25), ylim = c(0,100), main = \u0026quot;Rainfall Distribution\u0026quot;, xlab = \u0026quot;Month\u0026quot;, ylab = \u0026quot;Rainfall (in)\u0026quot;, color = Random \u0026gt; 5, size = 1) #Make a box plot with scatter (called jitter) qplot(x = Random, y = Categories, data = NewDataFrame, geom = c(\u0026quot;boxplot\u0026quot;, \u0026quot;jitter\u0026quot;), main = \u0026quot;Boxplot of Random Numbers\u0026quot;, color = Index)  Practice from last time: Load in the dataset penguins.csv, and plot the bill length vs body mass of penguins, coloring by species and changing the shape by island.\n#Load in the csv using read.csv() #View the data by using head() and find the names of the columns using str() #Use qplot to plot the columns that you\u0026#39;re interested in  Advanced Practice Using either dplyr or subsetting, plot the Gentoo penguins bill length vs body mass, and color by if their body mass is above 5500.\n# Your code below   Functions We’ve been using functions throughout this course; a function is anything that has an input and an output, often changing that input to create a different output. The functions that we’ve used so far have either been built into R such as mean(), dim(), sum(), and length(), or they have been loaded in as a package, such as dplyr::filter(), dplyr::summarize(), and ggplot::qplot().\nLet’s now look up the help menu for the function seq(). What does it do?\nhelp(seq) Let’s run this function with default values:\n#Uncomment this line to see what happens if you don\u0026#39;t include any values: #seq() #Let\u0026#39;s run this line to see what happens when you include only a single value: seq(5) ## [1] 1 2 3 4 5 Let’s include three numbers without explicitly calling each argument:\nseq(5,10,2) ## [1] 5 7 9 #This is the same as running: seq(from = 5, to = 10, by = 2) ## [1] 5 7 9 Let’s change up the order now:\n#This will also produce values that are equivalent: seq(to = 10, by = 2, from = 5) ## [1] 5 7 9 #But this will not: #seq(10, 2, 5) Practice Save a vector of values from 12 to 200, increasing by 4. Then print the last 10 values of this vector.\n#define your variable as the output of seq() #look at the documentation for tail() #print the last 10 values using tail()  Writing your own function We can write functions as well as using them. Today we’ll start off with a simple code to convert Celsius to Fahrenheit.\n#define your variable celcius \u0026lt;- 20 #calculate your new value farenheit \u0026lt;- 9/5 * celcius + 32 #print the new value farenheit ## [1] 68 Now let’s turn this into a function, using the function() function. Keep in mind that functions follow essentially the format of\n\\[y=f(x)\\]\nwhich can also be read as:\n\\[output = myfunction(input)\\]\nWhen we write this in code, we define the name of the function (below it’s c2f) as function(input){}, where inside the curly brackets {} there is the actual calculation. We then use the function return() to designate to the function what to output, which is our “y” in the above formula.\nc2f \u0026lt;- function(celcius) { farenheit = 9/5 * celcius + 32 return(farenheit) } What happens if we run this without an argument?\n#Run the following code: c2f() We need to include arguments for celcius:\n#Try explicitly stating the value c2f(celcius = 10) ## [1] 50 #What happens if we don\u0026#39;t define celcius? c2f(10) ## [1] 50 Finally, we can actually include a default when we create this function. Let’s add in something to c2f().\nc2f_adv \u0026lt;- function(celcius = 0) { farenheit \u0026lt;- 9/5 * celcius + 32 return(farenheit) } #now run the code without an argument to see what happens c2f_adv() ## [1] 32  Functions with two arguments: If we include x and y into the equation, we can set two variables values:\nmultiply \u0026lt;- function(x, y){x*y} Now we can run this, but it won’t work if we don’t give two arguments:\n#This does not work without defaults #multiply() #This will multiply 2 and 3: multiply(2,3) ## [1] 6 If we rewrite this function, then it will work if defaults are set:\nmultiply2 \u0026lt;- function(x = 2, y = 4){x*y} #This will multiply the default arguments multiply2() ## [1] 8 #This will multiply the inputs multiply2(3,10) ## [1] 30 #What happens if you only include one number? multiply2(10) ## [1] 40 multiply2(y = 10) ## [1] 20   Data Types So far we’ve been able to run calculations using variables, and used read.csv() to take in a character (the name of your file) that is converted into a data frame. We’ve also mentioned that data frame columns must be vectors of the same “type”. But what are the other data types that R can use?\nSome basic data types:\n Characters (char): “string” of text, which has the value of the text\n Numbers (num): overall class of numbers, which includes integers and doubles\n Integers (int): numbers without decimal points (takes less space)\n Doubles (dbl): floating point numbers, or those with precision (takes more space)\n Factors (fact): categorical elements which can be ordered (this sounds weird, but we’ll explain more later)\n  examplestring \u0026lt;- \u0026quot;This is a string of text\u0026quot; exampledouble \u0026lt;- 26.2 exampleinteger \u0026lt;- 5 #We can find out the data types by running typeof() typeof(examplestring) ## [1] \u0026quot;character\u0026quot; #What data types are exampledouble and exampleinteger? typeof(exampledouble) ## [1] \u0026quot;double\u0026quot; typeof(exampleinteger) ## [1] \u0026quot;double\u0026quot; #Notice that exampleinteger is also listed as a double; this is because R will automatically store numbers as doubles, and converts between numeric classes automatically realinteger \u0026lt;- as.integer(exampleinteger) typeof(realinteger) ## [1] \u0026quot;integer\u0026quot; When plotting, data types will change how plots view your data. For example, characters will often be unique values without order, numbers will often be continuous rather than discrete, and ordered alphabetically, and factors will be discrete and maintain an order. We will learn more about this soon, but we can use an example with qplot (which we’ve reviewed).\npenguins \u0026lt;- read.csv(\u0026quot;penguins.csv\u0026quot;) # How many colors are there when we color by island? qplot(x = bill_length_mm, y = bill_depth_mm, data = penguins, color = island) ## Warning: Removed 2 rows containing missing values (geom_point). # How many colors are there when we color by bill depth? qplot(x = bill_length_mm, y = bill_depth_mm, data = penguins, color = bill_depth_mm) ## Warning: Removed 2 rows containing missing values (geom_point). Answers to practice problems ## \u0026#39;data.frame\u0026#39;: 344 obs. of 8 variables: ## $ species : chr \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; \u0026quot;Adelie\u0026quot; ... ## $ island : chr \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; \u0026quot;Torgersen\u0026quot; ... ## $ bill_length_mm : num 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ... ## $ bill_depth_mm : num 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ... ## $ flipper_length_mm: int 181 186 195 NA 193 190 181 195 193 190 ... ## $ body_mass_g : int 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ... ## $ sex : chr \u0026quot;male\u0026quot; \u0026quot;female\u0026quot; \u0026quot;female\u0026quot; NA ... ## $ year : int 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ... ## Warning: Removed 2 rows containing missing values (geom_point). ## Warning: Removed 1 rows containing missing values (geom_point). ## Warning: Removed 1 rows containing missing values (geom_point).   ","date":1656374400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1656438129,"objectID":"d8278a20ced3788fc74356df608f2131","permalink":"https://nyusurp.github.io/2022/06/28/understanding-functions/","publishdate":"2022-06-28T00:00:00Z","relpermalink":"/2022/06/28/understanding-functions/","section":"handout","summary":"Review Let’s create our data frames again by running the following code:\nNewDataFrame \u0026lt;- data.frame(Random = c(4, 20, 10, 21, 63, 3, 14, 60, 9, 6), Index = 1:10, Categories = c(\u0026quot;Month\u0026quot;, \u0026quot;Day\u0026quot;, \u0026quot;Month\u0026quot;, \u0026quot;Day\u0026quot;, \u0026quot;Year\u0026quot;, \u0026quot;Month\u0026quot;, \u0026quot;Day\u0026quot;, \u0026quot;Year\u0026quot;, \u0026quot;Month\u0026quot;, \u0026quot;Day\u0026quot;)) Examples for plotting subsetted values If you wanted to plot only specific values, you could use these same booleans inside the functions to plot.","tags":[],"title":"Understanding Functions","type":"handout"},{"authors":["Cassandra Buzby"],"categories":["Handout"],"content":" Indexing What do we mean by indexing? So far, we’ve worked with data frames in R. Each data frame is really a set of rows and columns with values populated, and these can be broken down into what are called vectors. A vector is simply a one-dimensional set of something that can have at minimum length 1.\nWe can create vectors using the function c(), for concatenate.\nFirstVector \u0026lt;- c(4,20,10,21,60,3,14,63,9,6) FirstVector ## [1] 4 20 10 21 60 3 14 63 9 6 This vector has a length, and each number has an index within that vector. In the upper right, you can see that your FirstVector values are 1:10 and numeric. We can also use the length() function to find out how many elements we have in our vector.\nlength(FirstVector) ## [1] 10 If we wanted to identify the first value, we could use square brackets, ‘[]’, to identify that value. R will print the value that corresponds with that number.\nFirstVector[1] ## [1] 4 If we wanted to find the fifth value, we would use the following:\nFirstVector[5] ## [1] 60 #What is the 9th element in the vector? Write your code below: To make a set of numbers that is in a sequence by one, we can just use a ‘:’ to tell R to print that sequence. We can make a new vector using this:\nSecondVector \u0026lt;- 1:10 SecondVector ## [1] 1 2 3 4 5 6 7 8 9 10 Similarly, we can subset using the ‘:’ to ask R to give us a set of numbers to index by, such as the first three elements in the FirstVector.\nFirstVector[1:3] ## [1] 4 20 10 #Find the last 4 elements of SecondVector. Print your code below:  Indexing Data Frames If we wanted to make a data frame from vectors that we already have, we can use the data.frame() function to combine vectors of the same size. If the vectors are different sizes, R won’t know what to do with the extra slots and will give you an error.\n#Making a data frame from vectors NewDataFrame \u0026lt;- data.frame(Random = FirstVector, Index = SecondVector) NewDataFrame ## Random Index ## 1 4 1 ## 2 20 2 ## 3 10 3 ## 4 21 4 ## 5 60 5 ## 6 3 6 ## 7 14 7 ## 8 63 8 ## 9 9 9 ## 10 6 10 Instead of using length() to find out the size of a data frame, we would need to find the dimensions of that data frame. We briefly covered this function in earlier sessions: you can use dim().\ndim(NewDataFrame) ## [1] 10 2 The output of dim() is a vector, which gives the number of rows (first number) and the number of columns (second number). An easy way to remember this is “railroad car”, which always has R before C, or rows before columns.\nWhat if we wanted to find the first row of our data frame? We could use square brackets again, but this time we would need to add a column in between our row argument and our column argument. To select all of the values of one row or column, leave the element (before or after the comma) blank.\n#The following code will give the first row: NewDataFrame[1,] ## Random Index ## 1 4 1 #This next code will give the second column: NewDataFrame[,2] ## [1] 1 2 3 4 5 6 7 8 9 10 What if we wanted to find the first column and fourth row element? We would indicate both of these numbers in square brackets:\nNewDataFrame[4,1] ## [1] 21 #Find the third element of the second column below: #Find the last 3 elements of the first column below:  Using column names with $ If you wanted to refer to a column by name, you can do so with the $ operator. We can print the second column as such:\nNewDataFrame$Index ## [1] 1 2 3 4 5 6 7 8 9 10 If we wanted to select the second element of the Index column, we could do so using the square brackets as we did before; in this case, though, we now have a vector (the column) rather than a data frame, so we only need one dimension in our square brackets:\nNewDataFrame$Index[2] ## [1] 2 #Find the fourth element of the Random column below:   Logicals A review of Booleans Booleans are true/false statements that are evaluated by R. TRUE is encoded by a 1, and FALSE is encoded by a 0. R recognizes the words “TRUE” and “FALSE” when they are capitalized.\nWe can evaluate two numbers by using the ‘==’ sign between them:\n2 == 2 ## [1] TRUE 2 == 3 ## [1] FALSE We can also find the numbers in a vector that are equal to a certain number:\nFirstVector == 4 ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE Note that only the first element of FirstVector is 4; the rest are not, and so this evaluates to FALSE.\nWe can also use the \u0026lt; and \u0026gt; to evaluate, and \u0026lt;= and \u0026gt;=:\nFirstVector \u0026lt; 10 ## [1] TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE TRUE # Find all of the values of SecondVector that are greater than or equal to 4 # Find all of the values of FirstVector that are less than 5 We can also evaluate two vectors to see if they have the same values:\nFirstVector == NewDataFrame[,1] ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #Below, use \u0026#39;!=\u0026#39; to ask if FirstVector is NOT equal to the first column of NewDataFrame Finally, we can compare if two columns are equal in our data frame:\nNewDataFrame$Random == NewDataFrame$Index ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE   Subsetting Subsetting by values We’ve done this using dplyr in the past; we can take a data frame and filter it by a certain value. Without using the dplyr package, we can also do this based on the rows and column indices. Keep in mind that if you’re using the full name of the column,\n#First we can print the indices where the Random column equals 4 NewDataFrame$Random == 4 ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #By placing the true values in the square brackets, this code prints the rows where Rnadom is equal to 4 NewDataFrame[NewDataFrame$Random == 4,] ## Random Index ## 1 4 1 #Below, find the rows where the Random column is greater than 50 #Next, find the rows in which the Random column value is less than OR equal to the Index column value Of course, this can also be done using dplyr, but with naming columns and not the data frame:\nlibrary(dplyr) ## ## Attaching package: \u0026#39;dplyr\u0026#39; ## The following objects are masked from \u0026#39;package:stats\u0026#39;: ## ## filter, lag ## The following objects are masked from \u0026#39;package:base\u0026#39;: ## ## intersect, setdiff, setequal, union NewDataFrame %\u0026gt;% filter(Random == 4) ## Random Index ## 1 4 1  Putting it together Before we move on to visualizing, we can also create a new column in our data frame using $, and we can populate that by using booleans:\nNewDataFrame$NewColumn \u0026lt;- NewDataFrame$Random \u0026gt;= NewDataFrame$Index NewDataFrame ## Random Index NewColumn ## 1 4 1 TRUE ## 2 20 2 TRUE ## 3 10 3 TRUE ## 4 21 4 TRUE ## 5 60 5 TRUE ## 6 3 6 FALSE ## 7 14 7 TRUE ## 8 63 8 TRUE ## 9 9 9 TRUE ## 10 6 10 FALSE   Visualizing the subset Plotting subsetted values If you wanted to plot only specific values, you could use these same booleans inside the functions to plot. This is going to be the basis of how we separate out values in our plots.\nlibrary(ggplot2) # Plot our data frame here qplot(x = NewDataFrame$Random, y = NewDataFrame$Index) qplot(x = Random, y = Index, data = NewDataFrame) # We can change the size of our points by adding in the \u0026#39;size\u0026#39; argument qplot(x = NewDataFrame$Random, y = NewDataFrame$Index, size = 1) # Finally, we can add in coloring by a boolean logical qplot(x = NewDataFrame$Random, y = NewDataFrame$Index, color = NewDataFrame$Index \u0026gt; 5, size = 1) qplot(x = NewDataFrame$Random, y = NewDataFrame$Index, color = NewDataFrame$NewColumn, size = 1)   Exploring R One of the most important things to do in R is read the documentation for different packages and functions. If we look at the function for qplot, it will give us the options for our plots.\nWe can do this by either running help() or ?, as done below:\nhelp(qplot) ?qplot This has lots of options, but the examples show where they have options for size and color. We’ll get into how to use these (and more!) in ggplot later, but you can explore how to visualize your own data using qplot, as long as you remember to load ggplot2 into your workspace.\nYou’ll notice that there’s an option for geom. This is the type of plot that will be made, and the default is a scatter plot (so geom = “point”). You can find this in the defaults for geom.\n#Make a scatter plot qplot(x = Index, y = Random, data = NewDataFrame, geom = \u0026quot;point\u0026quot;, xlim = c(0,25), ylim = c(0,100), main = \u0026quot;Title of Randomness\u0026quot;, xlab = \u0026quot;Index Expanded\u0026quot;, ylab = \u0026quot;Random Numbers\u0026quot;, color = Random \u0026gt; 5, size = 1) #Make a box plot with scatter (called jitter) qplot(x = Random, y = NewColumn, data = NewDataFrame, geom = c(\u0026quot;boxplot\u0026quot;, \u0026quot;jitter\u0026quot;), main = \u0026quot;Boxplot of Random Numbers\u0026quot;, color = Index) Practice Load in the dataset penguins.csv, and plot the bill length vs body mass of penguins, coloring by species and changing the shape by island.\n#Load in the csv using read.csv() #View the data by using head() and find the names of the columns using str() #Use qplot to plot the columns that you\u0026#39;re interested in  Advanced Practice Using either dplyr or subsetting, plot the Gentoo penguins bill length vs body mass, and color by if their body mass is above 5500.\n# Your code below   ","date":1655942400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1656005619,"objectID":"01582d163ee51507a52c9ecdd5afb717","permalink":"https://nyusurp.github.io/2022/06/23/understanding-indexing-and-subsetting/","publishdate":"2022-06-23T00:00:00Z","relpermalink":"/2022/06/23/understanding-indexing-and-subsetting/","section":"handout","summary":"Indexing What do we mean by indexing? So far, we’ve worked with data frames in R. Each data frame is really a set of rows and columns with values populated, and these can be broken down into what are called vectors.","tags":[],"title":"Understanding Indexing and Subsetting","type":"handout"},{"authors":["Yen-Chung Chen"],"categories":["Handout"],"content":" Loading data Following what we did last week, we are going to keep working with the penguins today. You can find the dataset after you extracted session3.zip which you can download from here.\nFigure things out on the internet If you don’t remember how to do something with R and happen to be the most R-fluent people in the peer, don’t panic. Most of the time, searching for [what you want to do] in R work out great.\nOnline forums like StackOverflow and Kaggle often give great answers with code examples that you could play with. If you are a genomic person, Biostar and SEQanswers would be your friend.\nlibrary(dplyr) ## ## Attaching package: \u0026#39;dplyr\u0026#39; ## The following objects are masked from \u0026#39;package:stats\u0026#39;: ## ## filter, lag ## The following objects are masked from \u0026#39;package:base\u0026#39;: ## ## intersect, setdiff, setequal, union # How do you load a csv file with R? penguins \u0026lt;- read.csv(\u0026quot;penguins.csv\u0026quot;)  Figuring things out within R Oftentimes, an answer you found online provides a code that almost works, but you might not yet know enough to make it work. For times like this, R has documentation built in for each function describing the arguments that you can tweak and what it meant.\nYou can trigger the help page with ?[function] in the console. Let’s try it out: We used head() last week to take a glimpse of the first few rows of a table, so how do we print the first 3 instead of 6 rows?\nhead(penguins, n = 3) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18.0 195 3250 ## sex year ## 1 male 2007 ## 2 female 2007 ## 3 female 2007   count() things How many penguins of each species were observed on each island?\npenguins %\u0026gt;% count(island, species) ## island species n ## 1 Biscoe Adelie 44 ## 2 Biscoe Gentoo 124 ## 3 Dream Adelie 56 ## 4 Dream Chinstrap 68 ## 5 Torgersen Adelie 52 Which species is found on all islands? I know it’s obvious, but let’s use a sledgehammer to crack a nut this time.\n# The output in the previous chunk is also a table that could be count()ed. penguins %\u0026gt;% count(island, species) %\u0026gt;% count(species) ## species n ## 1 Adelie 3 ## 2 Chinstrap 1 ## 3 Gentoo 1  filter() out your species Let’s say you are interested in comparing how the islands influences the growth of penguins. Either you’ll need to go to Antarctica to observe more Gentoo or Chinstrap penguins on other islands, or only Adelie penguins make sense for your purpose.\n# Since none of us is going to leave for Antarctica any time soon (right?) # Let\u0026#39;s keep only the Adelie penguins, and **assign it to a new object**. adelie \u0026lt;- penguins %\u0026gt;% filter(species == \u0026quot;Adelie\u0026quot;) Revisiting the criteria for filter() There are 6 basic types of comparison:\n ==: Equal to !=: Not equal to \u0026gt;: Larger than \u0026gt;=: Larger or equal to \u0026lt;: Less than \u0026lt;=: Less than or equal to  # How many male Adelie penguins were observed? adelie %\u0026gt;% filter(sex == \u0026quot;male\u0026quot;) %\u0026gt;% count() ## n ## 1 73 # How many Adelie penguins were found on islands that are not Dream island? adelie %\u0026gt;% filter(island != \u0026quot;Dream\u0026quot;) %\u0026gt;% count() ## n ## 1 96 # How many Adelie penguins were observed during or before 2008? adelie %\u0026gt;% filter(year \u0026lt;= 2008) %\u0026gt;% count() ## n ## 1 100  Combining criteria Sometimes, we’ll need more than one criteria to get the data we want. For example, if you are interested in the female Adelie penguins on the Biscoe island:\nadelie %\u0026gt;% filter(sex == \u0026quot;female\u0026quot;, island == \u0026quot;Biscoe\u0026quot;) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 1 Adelie Biscoe 37.8 18.3 174 3400 ## 2 Adelie Biscoe 35.9 19.2 189 3800 ## 3 Adelie Biscoe 35.3 18.9 187 3800 ## 4 Adelie Biscoe 40.5 17.9 187 3200 ## 5 Adelie Biscoe 37.9 18.6 172 3150 ## 6 Adelie Biscoe 39.6 17.7 186 3500 ## 7 Adelie Biscoe 35.0 17.9 190 3450 ## 8 Adelie Biscoe 34.5 18.1 187 2900 ## 9 Adelie Biscoe 39.0 17.5 186 3550 ## 10 Adelie Biscoe 36.5 16.6 181 2850 ## 11 Adelie Biscoe 35.7 16.9 185 3150 ## 12 Adelie Biscoe 37.6 17.0 185 3600 ## 13 Adelie Biscoe 36.4 17.1 184 2850 ## 14 Adelie Biscoe 35.5 16.2 195 3350 ## 15 Adelie Biscoe 35.0 17.9 192 3725 ## 16 Adelie Biscoe 37.7 16.0 183 3075 ## 17 Adelie Biscoe 37.9 18.6 193 2925 ## 18 Adelie Biscoe 38.6 17.2 199 3750 ## 19 Adelie Biscoe 38.1 17.0 181 3175 ## 20 Adelie Biscoe 38.1 16.5 198 3825 ## 21 Adelie Biscoe 39.7 17.7 193 3200 ## 22 Adelie Biscoe 39.6 20.7 191 3900 ## sex year ## 1 female 2007 ## 2 female 2007 ## 3 female 2007 ## 4 female 2007 ## 5 female 2007 ## 6 female 2008 ## 7 female 2008 ## 8 female 2008 ## 9 female 2008 ## 10 female 2008 ## 11 female 2008 ## 12 female 2008 ## 13 female 2008 ## 14 female 2008 ## 15 female 2009 ## 16 female 2009 ## 17 female 2009 ## 18 female 2009 ## 19 female 2009 ## 20 female 2009 ## 21 female 2009 ## 22 female 2009 What if you need penguins with extreme body weight? Say either over 4700g or below 2900g.\nadelie %\u0026gt;% filter(body_mass_g \u0026gt; 4700 | body_mass_g \u0026lt; 2900) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 1 Adelie Biscoe 36.5 16.6 181 2850 ## 2 Adelie Biscoe 36.4 17.1 184 2850 ## 3 Adelie Biscoe 41.0 20.0 203 4725 ## 4 Adelie Biscoe 43.2 19.0 197 4775 ## sex year ## 1 female 2008 ## 2 female 2008 ## 3 male 2009 ## 4 male 2009 Logical operations: What’s happening under the dplyr table Essentially, what filter() relies on is to ask a series of yes/no question to each row of a column, and the answers to these yes/no questions are called Boolean or logical values.\nIn R, TRUE means yes, while FALSE means no.\n# Is 3 larger than 5? 3 \u0026gt; 5 ## [1] FALSE # Is 2022 equal to 2020? 2022 == 2020 ## [1] FALSE # Is \u0026quot;apple\u0026quot; not equal to \u0026quot;orange\u0026quot;? \u0026quot;apple\u0026quot; != \u0026quot;orange\u0026quot; ## [1] TRUE These logical values can be further calculated with \u0026amp; (AND), | (OR), and xor().\n   \u0026amp; | xor()    TRUE/TRUE TRUE TRUE FALSE  TRUE/FALSE FALSE TRUE TRUE  FALSE/TRUE FALSE TRUE TRUE  FALSE/FALSE FALSE FALSE FALSE    So, how many Adelie penguins either have a bill length shorter than 35mm or a bill depth below 15mm?\nadelie %\u0026gt;% filter(bill_length_mm \u0026lt; 35 | bill_depth_mm \u0026lt; 15) %\u0026gt;% count() ## n ## 1 9 Now that we know filter() is working with logical values, you won’t be surprised that it can also use other functions that gives a logical value as its output as a criterion.\nFor example, we mentioned that NA is how R labels missing data. Since we are interested in body weight, we might want throw away rows with missing body weight…\n# You might want to try filtering for body_mass_g== NA adelie %\u0026gt;% filter(body_mass_g == NA) ## [1] species island bill_length_mm bill_depth_mm ## [5] flipper_length_mm body_mass_g sex year ## \u0026lt;0 rows\u0026gt; (or 0-length row.names) What is happening? Remember that we said R treats NA very differently. As a matter of fact, almost every operation gives you NA when NA is involved.\n# Try these 5 == NA ## [1] NA 3 \u0026gt; NA ## [1] NA \u0026quot;North America\u0026quot; != NA ## [1] NA 3.1415926 \u0026lt;= NA ## [1] NA Since NA is missing data, this actually makes sense:\n5 == NA is like asking “is 5 equal to something I don’t know?”, and the answer has to be “I don’t know”.\nSo, how do we ask R if it doesn’t know something or has an NA there? We use is.na().\nis.na(NA) ## [1] TRUE is.na(\u0026quot;National Academy\u0026quot;) ## [1] FALSE You can use is.na() with filter() to find the rows where body weight is NA.\n# Use is.na() to get rows with NA in body_mass_g adelie %\u0026gt;% filter(is.na(body_mass_g)) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 1 Adelie Torgersen NA NA NA NA ## sex year ## 1 \u0026lt;NA\u0026gt; 2007 How do we select all other rows then? In R, ! flips a logical value, and you can pronounce it as not.\n# Not TRUE !TRUE ## [1] FALSE # Not FALSE !FALSE ## [1] TRUE # Flipping (3 \u0026gt; 5) !(3 \u0026gt; 5) ## [1] TRUE We can use ! to find rows that are not NA.\n# How many Adelie penguins have their body mass recorded? adelie %\u0026gt;% filter(!is.na(body_mass_g)) %\u0026gt;% count() ## n ## 1 151   Extended reading: Dealing with missing values Depends on what you work with, you might not always want to drop missing values.\nIf you are not going to throw those data away, you’ll need to ask yourself questions like “Does missing value appear randomly?”, and decide how to best deal with them.\nIf you are interested, Hadley Wickham has a section in his book R for Data Science discussing this.\n  Group your data for further analysis Let’s say we are interested in how body weight differs between islands. To perform this analysis, we might want to calculate the median and standard deviation of body mass per island.\nTo indicate how dplyr should group your data, we use group_by() to tell it which column contains the group labels.\nLet’s assign the grouped data to another object named adelie_per_island\nadelie_per_island \u0026lt;- adelie %\u0026gt;% filter(!is.na(body_mass_g)) %\u0026gt;% group_by(island)  Get summary statistics with summarize() Now that we grouped the data, we can calculate the summary statistics.\nThe syntax for summarize() is as follows:\n# You tell summarize() which functions to use on which column adelie_per_island %\u0026gt;% summarize(mean(body_mass_g)) ## # A tibble: 3 × 2 ## island `mean(body_mass_g)` ## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; ## 1 Biscoe 3710. ## 2 Dream 3688. ## 3 Torgersen 3706. By default, the column names of the summary table is the function call we gives to summarize(), which could be a bit ugly. We can rename the columns by:\nadelie_per_island %\u0026gt;% summarize(mean_bw = mean(body_mass_g)) ## # A tibble: 3 × 2 ## island mean_bw ## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; ## 1 Biscoe 3710. ## 2 Dream 3688. ## 3 Torgersen 3706. The summary statistics that we use the most often are:\n Arithmetic mean (mean()) Median (median()) Standard deviation (sd())  Let’s summarize the data with median and standard deviation per island.\n# Summarize the Adelie subset per island with the median and standard deviation # of the body mass adelie_per_island %\u0026gt;% summarize(bw_median = median(body_mass_g), bw_sd = sd(body_mass_g)) ## # A tibble: 3 × 3 ## island bw_median bw_sd ## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 Biscoe 3750 488. ## 2 Dream 3575 455. ## 3 Torgersen 3700 445. What if you don’t group? adelie %\u0026gt;% filter(!is.na(body_mass_g)) %\u0026gt;% summarize(bw_median = median(body_mass_g), bw_sd = sd(body_mass_g)) ## bw_median bw_sd ## 1 3700 458.5661  What if you want to group with another grouping variable? # Let\u0026#39;s group with sex adelie %\u0026gt;% filter(!is.na(body_mass_g), !is.na(sex)) %\u0026gt;% group_by(sex) %\u0026gt;% summarize(bw_median = median(body_mass_g), bw_sd = sd(body_mass_g)) ## # A tibble: 2 × 3 ## sex bw_median bw_sd ## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; ## 1 female 3400 269. ## 2 male 4000 347.   A picture is worth a thousand words While it’s great to have summary statistics, oftentimes a quick visualization of our data will be very helpful.\nqplot() provided by ggplot2 is designed for this purpose and can be easily incorporated into your pipeline.\nExample: a quick scatter/strip plot per island Let’s plot something with points on a plane where the x-axis is the islands and the y-axis is the body weight.\n# Load ggplot2 library(ggplot2) adelie_per_island %\u0026gt;% qplot(data = ., x = island, y = body_mass_g, geom = \u0026quot;point\u0026quot;) There several required arguments for qplot():\n data: The data you want to plot. x: The column name of the variable you want to use as the x-axis y: The column name of the variable you want to use as the y-axis color: The column name of the variable you want to color your plot by geom: Short for “geometry”, the type of plots you want to do. Popular ones include:  point bar boxplot violin histogram density   # Let\u0026#39;s do a boxplot instead adelie_per_island %\u0026gt;% qplot(data = ., x = island, y = body_mass_g, geom = \u0026quot;boxplot\u0026quot;) ### What is the distribution of bill lengths of the whole dataset?\n# Plot a histogram with bill lengths on the x-axis penguins %\u0026gt;% qplot(data = ., x = bill_length_mm, geom = \u0026quot;histogram\u0026quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 2 rows containing non-finite values (stat_bin).  Is bill length and depth correlated for the Adelie penguins? # Plot a point plot with bill length on the x, bill depth on the y, and # color by sex adelie %\u0026gt;% qplot( data = ., x = bill_length_mm, y = bill_depth_mm, color = sex, geom = \u0026quot;point\u0026quot; ) ## Warning: Removed 1 rows containing missing values (geom_point).   ","date":1655769600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655822237,"objectID":"58ef06c157656a34056cf58caba5bfb4","permalink":"https://nyusurp.github.io/2022/06/21/hands-on-data-wrangling/","publishdate":"2022-06-21T00:00:00Z","relpermalink":"/2022/06/21/hands-on-data-wrangling/","section":"handout","summary":"Loading data Following what we did last week, we are going to keep working with the penguins today. You can find the dataset after you extracted session3.zip which you can download from here.","tags":[],"title":"Hands-On Data Wrangling","type":"handout"},{"authors":["Yen-Chung Chen"],"categories":["Jargon"],"content":"There are two different ways to represent where a file is: Absolute and relative.\nAbsolute path for a file is using the root as the starting point (/ for Linux and Mac and C:\\ for Windows). This is usually clear to the computer, but it can be really long and not comprehensible to human and thus impossible to wrap our heads around it and write.\nFor example, I had a note stored in /Users/ycc/Library/Mobile Documents/iCloud~md~obsidian/Documents/YCC/Reading note/@gold.brand_2014.md. There is no way I can remember this and type it when writing a script.\nRelative path is much shorter, but it could be tricky because sometimes where the path is defined relative to is unclear.\nIn R, you can find the working directory with getwd(), which gives you the absolute path of the reference.\nSay your working directory is /Users/me/my_cool_project, and you have a csv file (named myawesome.csv) stored in a subdirectory called \u0026ldquo;data\u0026rdquo;, you can write data/myawesome.csv in R, and R will append /Users/me/my_cool_project before your relative path for you.\nIf you need to ask R to find /Users/me/a_file_outside_wd.txt for you, relative path still has you covered outside your working directory: .. means go up to the parent folder in relative paths, so /Users/me/a_file_outside_wd.txt is ../a_file_outside_wd.txt if your working directory is /Users/me/my_cool_project.\nFor tips to set working directories in RStudio, you might also want to check the official documentation.\n","date":1655164800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655211409,"objectID":"8f828c0d6f0e6031fc4be90266ea4c2b","permalink":"https://nyusurp.github.io/2022/06/14/working-directories/","publishdate":"2022-06-14T00:00:00Z","relpermalink":"/2022/06/14/working-directories/","section":"extra","summary":"There are two different ways to represent where a file is: Absolute and relative.\nAbsolute path for a file is using the root as the starting point (/ for Linux and Mac and C:\\ for Windows).","tags":[],"title":"Working directories","type":"extra"},{"authors":["Cassandra Buzby"],"categories":["Handout"],"content":" AGENDA Introductions Installing R This Worksheet :)   Adpated from material curated by Eugene Plavskin and Grace Avecilla\n  Exploring RStudio  The console: Where you run commands one by one (bottom) The environment: Where you can see what is loaded in R (upper right) The file explorer: An easier way for you to find files (otherwise you’ll need to know the path of a file to use it in R; lower right)   Installing packages  Packages are like kits in experiments: They package the reagents and instructions for otherwise complicated processes for you.\n We’ll be installing 3 packages today\n rmarkdown: A tool that allows you to write your code along with your notes ggplot2: A handy and powerful visualization tool dplyr: A tool that handles and summarizes tables   # This is how we ask R to install packages # R will try to ask several central repositories if they have this package install.packages(\u0026quot;rmarkdown\u0026quot;)  Using Rmarkdown Rmarkdown file allow you to record your thinking process (as text) along with your analyses (as code chunks).\nHaving why you are doing the analysis and the specific code for it will help you catch up faster if you ever need to go back to the same analysis again.\nText and code This is a line of text:\n“I know how to use R!”\n# This is a chunk of code. Do you notice that the background looks different? # Also there is three buttons at the upper right corner # Press the _play_ button, and the output will be shown below the chunk print(\u0026quot;I know how to use R\u0026quot;) ## [1] \u0026quot;I know how to use R\u0026quot; 2+2 ## [1] 4  Running code:\n Click on the run button on the upper-right corner of a chunk\n Ctrl + Enter (Windows) / Cmd + Return (Mac)\n Generating output\n Click the knit button on the upper rim of the editor Knitting will re-run all your code in the file from scratch, which is a good thing because it makes sure:  The code works on its own We haven’t accidentally deleted or added some lines of code that will break the code.      Working directory and Rstudio projects What is a working directory? A working directory is where R will try to find things if you ask it to1.\n Checking and setting your working directory You can check the path of your working directory with getwd() (short for get working directory).\n# Expect to see a path printed below # This is where R find things for you getwd() ## [1] \u0026quot;/Users/ycc/Dropbox/Docs/NYU/Teaching/SURP/NYU_SURP_blogdown/content/handout/2022-06-13-prepare-your-computer-for-r\u0026quot;  Loading files from your working directory Now that you have a directory, files inside that directory can be loaded using functions like read.csv(). This function will take a comma-separated file (which you can make in Excel) and allow you to save it as a variable that R can work with.\nFor the example below, mytestdata.csv can be found in the example data.\n# Open the csv file with Excel or Google Sheet to take a look # mytestdata # And then we load it to see how it looks like in R read.csv(\u0026quot;mytestdata.csv\u0026quot;) ## Day Count Group ## 1 1 12 1 ## 2 1 15 2 ## 3 2 8 1 ## 4 2 3 2 ## 5 3 10 1 ## 6 3 24 2 # You need to ask R to keep the csv files # *Check the environment tab on the upper right corner of your window mytestdata \u0026lt;- read.csv(\u0026quot;mytestdata.csv\u0026quot;) # You can ask R to retrieve what it keeps later by the name you gave to the data mytestdata ## Day Count Group ## 1 1 12 1 ## 2 1 15 2 ## 3 2 8 1 ## 4 2 3 2 ## 5 3 10 1 ## 6 3 24 2   Basic usage of R: Using it as a calculator Enter the following line of command in the console\n17 + 2.3 ## [1] 19.3 In programming, division is often written as slashes (/), while multiplication is written as asterisks (*). Now, let’s try doing these in the console as well:\n# Try multiplying 8 by 7 8*7 ## [1] 56 # Try dividing 48 by 12 48/12 ## [1] 4  An example of our data Cassandra’s data is allele frequencies as read counts from sequencing. To analyze it, she first:\nloads in the data, runs an R function to analyze it, plots using ggplot2.  Here is a quick version of this:\nlibrary(ggplot2) library(dplyr) ## ## Attaching package: \u0026#39;dplyr\u0026#39; ## The following objects are masked from \u0026#39;package:stats\u0026#39;: ## ## filter, lag ## The following objects are masked from \u0026#39;package:base\u0026#39;: ## ## intersect, setdiff, setequal, union library(tidyr) #Read in the data WeightedMeanZStats.100 \u0026lt;- read.csv(\u0026quot;CBData.csv\u0026quot;) #Look at the data (this only prints the first 6 rows) head(WeightedMeanZStats.100) ## X CHROM POS Bulk Parent Int Stat ## 1 result.1 II 100153 -2.3893709 -1.0534663 1.64175559 Z ## 2 result.2 II 100367 -0.9361101 -0.2837268 0.55031705 Z ## 3 result.3 II 100413 -1.1028976 -0.6802854 0.95854049 Z ## 4 result.4 II 100878 0.7191787 0.9999416 -1.25245792 Z ## 5 result.5 II 101289 -1.2163032 1.4995884 0.07063202 Z ## 6 result.6 II 101340 -1.4019217 1.1382948 -0.29809070 Z #Find the dimensions of the datast dim(WeightedMeanZStats.100) ## [1] 95106 7 unique(WeightedMeanZStats.100$Stat) ## [1] \u0026quot;Z\u0026quot; \u0026quot;ZPrime\u0026quot; #Plot the data using ggplot (which we\u0026#39;ll go into more later!) WeightedMeanZStats.100 %\u0026gt;% filter(Stat == \u0026quot;ZPrime\u0026quot;) %\u0026gt;% pivot_longer(c(\u0026quot;Bulk\u0026quot;, \u0026quot;Parent\u0026quot;, \u0026quot;Int\u0026quot;)) %\u0026gt;% ggplot(., aes(x = POS, y = value, color = name)) + geom_line(size = 1) + #geom_point(alpha = 0.1) + #+ geom_hline(yintercept = 0, color = \u0026quot;gray\u0026quot;) + geom_hline(yintercept = c(1.96, -1.96), color = \u0026quot;black\u0026quot;, linetype = \u0026quot;dashed\u0026quot;) + theme(axis.text.x = element_blank()) + ylab(\u0026quot;Oak \u0026lt;- Effect -\u0026gt; Wine\u0026quot;) + scale_color_manual(values = c(\u0026quot;violet\u0026quot;, \u0026quot;lightblue\u0026quot;, \u0026quot;darkorange\u0026quot;)) + facet_grid(~CHROM, scales = \u0026quot;free\u0026quot;) + ggtitle(\u0026quot;Comparison of Zprime per Factor | Weighted Means W = 100\u0026quot;)   See working directory if you are interested.↩︎\n   ","date":1655078400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655167125,"objectID":"ebda1f992433a7d69beb10ea13a3ed69","permalink":"https://nyusurp.github.io/2022/06/13/prepare-your-computer-for-r/","publishdate":"2022-06-13T00:00:00Z","relpermalink":"/2022/06/13/prepare-your-computer-for-r/","section":"handout","summary":"AGENDA Introductions Installing R This Worksheet :)   Adpated from material curated by Eugene Plavskin and Grace Avecilla\n  Exploring RStudio  The console: Where you run commands one by one (bottom) The environment: Where you can see what is loaded in R (upper right) The file explorer: An easier way for you to find files (otherwise you’ll need to know the path of a file to use it in R; lower right)   Installing packages  Packages are like kits in experiments: They package the reagents and instructions for otherwise complicated processes for you.","tags":[],"title":"Prepare your computer for R","type":"handout"},{"authors":null,"categories":null,"content":"The contents provided on this website are for information purposes only. We have no intention to provide professional advice via this website, and the information is for discussion and communication only. Please consult a professional person before applying any information posted on this website.\nWe are not responsible for the accuracy, completeness, and timeliness of any information on or linked from this website. We are not liable for any errors or omissions of this information, and the availability of information provided by or linked from the website is not warranted. I am not liable for any damage resulting from or related to the use of this information.\nInformation in this website is licensed under CC BY-NC-ND 4.0 unless otherwise specified in the material. We retain the right to change the terms and conditions at any time and without notice.\n","date":1591225200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591225200,"objectID":"9b10c1f64082d3869fd4cb1f85809430","permalink":"https://nyusurp.github.io/terms/","publishdate":"2020-06-04T00:00:00+01:00","relpermalink":"/terms/","section":"","summary":"The contents provided on this website are for information purposes only. We have no intention to provide professional advice via this website, and the information is for discussion and communication only.","tags":null,"title":"Terms","type":"page"},{"authors":null,"categories":null,"content":"Who we are? This is a course website (https://nyusurp.github.io) for the R workshop at NYU. The site is currently maintained by Yen-Chung Chen, who is not an expert in website technology nor in privacy law, so the following description is to the best of my understanding of how this website is built and my intentions. If you suspect your privacy is compromised while browsing, please don\u0026rsquo;t hesitate to contact me.\nThe website is written with blogdown, the source is hosted on Github and rendered by Hugo.\nCollection of your personal information The website does not identify you nor track the traffic.\nSharing of your personal information This website does not collect personal information.\n","date":1577833200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577833200,"objectID":"18d05a63a1c8d7ed973cc51838494e41","permalink":"https://nyusurp.github.io/privacy/","publishdate":"2020-01-01T00:00:00+01:00","relpermalink":"/privacy/","section":"","summary":"Who we are? This is a course website (https://nyusurp.github.io) for the R workshop at NYU. The site is currently maintained by Yen-Chung Chen, who is not an expert in website technology nor in privacy law, so the following description is to the best of my understanding of how this website is built and my intentions.","tags":null,"title":"Privacy Policy","type":"page"}]