<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Session 5: Data frames and logical operation</title>
    <meta charset="utf-8" />
    <meta name="author" content="Yen-Chung Chen" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="libs/default.css" type="text/css" />
    <link rel="stylesheet" href="libs/default-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Session 5: Data frames and logical operation
### Yen-Chung Chen
### Desplan Lab, New York University
### 2021/07/06

---

class: center, middle



Adapted from material curated by Eugene Plavskin and Grace Avecilla

---

class: inverse, center, middle

# Quick recap: Subsetting vectors

---

# A vector is a series of similar items

Let's first execute the first chunk in the worksheet to assign the example variables containing the [recent Nobel laureates in physiology or medicine](https://www.nobelprize.org/prizes/lists/all-nobel-laureates-in-physiology-or-medicine/).



--

Check the environment tab in upper right quadrant.There should be 3 variables defined in the environment: 


--

- `nobel_prize_winners`
- `nobel_prize_year`
- `nobel_prize_topic`

---

# You can _subset_ a vector by its index

--

- Indices can be numbers indicating which item you want to retrieve from the vector.

--

- An index should be put between a pair of square brackets

--

### Who is the third person that won Nobel prize in the vector?


```r
nobel_prize_winners[3]
```

```
## [1] "Charles Rice"
```

---


# Your turn: When did the third person in the vector won Nobel prize?

&gt; Hint: This data is in nobel_prize_year

--


```r
nobel_prize_year[3]
```

```
## [1] 2020
```

---

# A vector index can be a numeric vector


```r
# Let's retrieve the topic of the 3rd to 6th person in the vector
index_to_retrieve &lt;- c(3, 4, 5, 6)
print(nobel_prize_topic[index_to_retrieve])
```

```
## [1] "Discovery of hepatitis C virus"                               
## [2] "Discovery of how cells sense and adapt to oxygen availability"
## [3] "Discovery of how cells sense and adapt to oxygen availability"
## [4] "Discovery of how cells sense and adapt to oxygen availability"
```

---

# Alternative use of `[]`

--

```r
# Note that the above chunk is exactly the same as
nobel_prize_topic[c(3, 4, 5, 6)]
```

```
## [1] "Discovery of hepatitis C virus"                               
## [2] "Discovery of how cells sense and adapt to oxygen availability"
## [3] "Discovery of how cells sense and adapt to oxygen availability"
## [4] "Discovery of how cells sense and adapt to oxygen availability"
```
--

```r
# and also the same as
nobel_prize_topic[3:6]
```

```
## [1] "Discovery of hepatitis C virus"                               
## [2] "Discovery of how cells sense and adapt to oxygen availability"
## [3] "Discovery of how cells sense and adapt to oxygen availability"
## [4] "Discovery of how cells sense and adapt to oxygen availability"
```
--

```r
# and also
nobel_prize_topic[seq(3, 6, by = 1)]
```

```
## [1] "Discovery of hepatitis C virus"                               
## [2] "Discovery of how cells sense and adapt to oxygen availability"
## [3] "Discovery of how cells sense and adapt to oxygen availability"
## [4] "Discovery of how cells sense and adapt to oxygen availability"
```

---
class: inverse, right, middle

## What we will discuss today

--

1. Why would I ever want to subset vectors with indices?

--

2. How do I make data frames and use them?

---

# Who did win Nobel prize in 2018?


```r
# Just showing the vectors since I don't remember what's inside
print(nobel_prize_winners)
```

```
##  [1] "Harvey Alter"       "Michael Houghton"   "Charles Rice"      
##  [4] "Peter Ratcliffe"    "William Kaelin Jr." "Gregg Semenza"     
##  [7] "James Allison"      "Tasuku Honjo"       "Jeffery Hall"      
## [10] "Michael Rosbach"    "Michael Young"
```

```r
print(nobel_prize_year)
```

```
##  [1] 2020 2020 2020 2019 2019 2019 2018 2018 2017 2017 2017
```

---

# Logical data is just the answers to yes/no questions.

You can ask R yes/no questions with _logical operators_. `TRUE` is yes while `FALSE` is no.

--

- `A == B`: Is A _exactly_ equal to B?

--

- `A != B`: Is A not equal to B?

--

- `A &lt; B`: Is A smaller than B?

--

- `A &gt; B`: Is A larger than B?

--

- `A %in% B`: Is A an element of B? (Or, does B contain A? B is a vector).

---

# Using logical operators

--


```r
1 + 1 == 2
```

```
## [1] TRUE
```

--


```r
-3 &lt; 5
```

```
## [1] TRUE
```

--


```r
# Weird things will happen here
3&lt;-5
```

```
## Error in 3 &lt;- 5: invalid (do_set) left-hand side to assignment
```

--


```r
3 %in% c(1, 2, 3, 4, 5)
```

```
## [1] TRUE
```

---

# Your turn: Do I have 2018 in `nobel_prize_year`?

&gt; Hint: %in%

--


```r
2018 %in% nobel_prize_year
```

```
## [1] TRUE
```

---

# Logical operators work on vectors

Just like arithmetic operators, logical operators also work on vectors. Not only can you as if A is equal to B with `A == B`, you can also ask if every element of A is equal to B with the same syntax.


```r
count_to_3 &lt;- c(1:3)

count_to_3 == 2
```

```
## [1] FALSE  TRUE FALSE
```

---

# I don't like reading `TRUE` and `FALSE`...

Instead of looking at a vector of `TRUE` or `FALSE`, you might want to ask _which items are `TRUE`?_. Not surprisingly, there's a function for it, named `which()`.

--

`which()` takes a logical vector as its argument, and returns the indicies of the `TRUE` items.

--


```r
odds_are_true &lt;- c(TRUE, FALSE, TRUE, FALSE, TRUE)
which(odds_are_true)
```

```
## [1] 1 3 5
```

---

# Your turn: Finding 3

In vector count_to_3, use `which()` to tell which item is 3.


```r
count_to_3
```

```
## [1] 1 2 3
```

--


```r
which(count_to_3 == 3)
```

```
## [1] 3
```

---

# Your turn: Which items in nobel_prize_year are 2018?

--


```r
index_2018 &lt;- which(nobel_prize_year == 2018)
print(index_2018)
```

```
## [1] 7 8
```

--

You can use `index_2018` to retrieve information from other vectors to answer questions like: Who won Nobel prize in 2018, and what is their research contribution?

--


```r
print(nobel_prize_winners[index_2018])
```

```
## [1] "James Allison" "Tasuku Honjo"
```

```r
print(nobel_prize_topic[index_2018])
```

```
## [1] "Cancer immunotherapy by inhibiting the negative regulation of immune response"
## [2] "Cancer immunotherapy by inhibiting the negative regulation of immune response"
```

---

# Data frames

Most of the time, we prefer to work with tables because our data usually does not fit in a vector, and it's tedious to have vectors scattering around.

--

`data.frame()` take multiple vectors separated by commas as its argument, and returns a data.frame.

--


```r
recent_nobel_med &lt;- data.frame(
  nobel_prize_winners,
  nobel_prize_year,
  nobel_prize_topic
)
print(recent_nobel_med)
```

```
##    nobel_prize_winners nobel_prize_year
## 1         Harvey Alter             2020
## 2     Michael Houghton             2020
## 3         Charles Rice             2020
## 4      Peter Ratcliffe             2019
## 5   William Kaelin Jr.             2019
## 6        Gregg Semenza             2019
## 7        James Allison             2018
## 8         Tasuku Honjo             2018
## 9         Jeffery Hall             2017
## 10     Michael Rosbach             2017
## 11       Michael Young             2017
##                                                                nobel_prize_topic
## 1                                                 Discovery of hepatitis C virus
## 2                                                 Discovery of hepatitis C virus
## 3                                                 Discovery of hepatitis C virus
## 4                  Discovery of how cells sense and adapt to oxygen availability
## 5                  Discovery of how cells sense and adapt to oxygen availability
## 6                  Discovery of how cells sense and adapt to oxygen availability
## 7  Cancer immunotherapy by inhibiting the negative regulation of immune response
## 8  Cancer immunotherapy by inhibiting the negative regulation of immune response
## 9                           Discovery of the molecular basis of circadian rhythm
## 10                          Discovery of the molecular basis of circadian rhythm
## 11                          Discovery of the molecular basis of circadian rhythm
```

---

# Access cells by index: `[row, column]`


```r
recent_nobel_med[1, 3]
```

```
## [1] "Discovery of hepatitis C virus"
```

--

If we leave row/column index blank, the whole column/row will be retrieved


```r
## Getting the first row
recent_nobel_med[1, ]
```

```
##   nobel_prize_winners nobel_prize_year              nobel_prize_topic
## 1        Harvey Alter             2020 Discovery of hepatitis C virus
```

--



```r
## Getting the second column
recent_nobel_med[ , 2]
```

```
##  [1] 2020 2020 2020 2019 2019 2019 2018 2018 2017 2017 2017
```

---

# Subseting a data frame by row

What if you only want the data from 2017? You first need the information stored in the year column.

--


```r
# You already know how to get the year column
recent_nobel_med[ , 2]
```

```
##  [1] 2020 2020 2020 2019 2019 2019 2018 2018 2017 2017 2017
```

--

The column is something that you have been familiar with.


```r
# Hello vector my old friend
is(recent_nobel_med[ , 2])
```

```
## [1] "numeric" "vector"
```

---

# Creating a index vector to subset a data frame


```r
# Assign a index_2017 to subset the data frame
index_2017 &lt;- which(recent_nobel_med[ , 2] == 2017)
print(index_2017)
```

```
## [1]  9 10 11
```

--


```r
# Subset the data frame with the index you just get
recent_nobel_med[index_2017, ]
```

```
##    nobel_prize_winners nobel_prize_year
## 9         Jeffery Hall             2017
## 10     Michael Rosbach             2017
## 11       Michael Young             2017
##                                       nobel_prize_topic
## 9  Discovery of the molecular basis of circadian rhythm
## 10 Discovery of the molecular basis of circadian rhythm
## 11 Discovery of the molecular basis of circadian rhythm
```

---

# Columns can by accessed by their names

It can be very painful to remember the indices of columns when you have a large table, so R provides other ways for you to access a column.


```r
recent_nobel_med
```

```
##    nobel_prize_winners nobel_prize_year
## 1         Harvey Alter             2020
## 2     Michael Houghton             2020
## 3         Charles Rice             2020
## 4      Peter Ratcliffe             2019
## 5   William Kaelin Jr.             2019
## 6        Gregg Semenza             2019
## 7        James Allison             2018
## 8         Tasuku Honjo             2018
## 9         Jeffery Hall             2017
## 10     Michael Rosbach             2017
## 11       Michael Young             2017
##                                                                nobel_prize_topic
## 1                                                 Discovery of hepatitis C virus
## 2                                                 Discovery of hepatitis C virus
## 3                                                 Discovery of hepatitis C virus
## 4                  Discovery of how cells sense and adapt to oxygen availability
## 5                  Discovery of how cells sense and adapt to oxygen availability
## 6                  Discovery of how cells sense and adapt to oxygen availability
## 7  Cancer immunotherapy by inhibiting the negative regulation of immune response
## 8  Cancer immunotherapy by inhibiting the negative regulation of immune response
## 9                           Discovery of the molecular basis of circadian rhythm
## 10                          Discovery of the molecular basis of circadian rhythm
## 11                          Discovery of the molecular basis of circadian rhythm
```

---

# Checking column names with `colnames()`

You can check the column names by viewing the data frame, or by using `colnames()`, which takes a data frame and returns the column names as a character vector.


```r
colnames(recent_nobel_med)
```

```
## [1] "nobel_prize_winners" "nobel_prize_year"    "nobel_prize_topic"
```

---

# Call a column by its name

You can retrieve columns by their names using a dollar sign `$`.

--


```r
# Get the laureate column
recent_nobel_med$nobel_prize_winners
```

```
##  [1] "Harvey Alter"       "Michael Houghton"   "Charles Rice"      
##  [4] "Peter Ratcliffe"    "William Kaelin Jr." "Gregg Semenza"     
##  [7] "James Allison"      "Tasuku Honjo"       "Jeffery Hall"      
## [10] "Michael Rosbach"    "Michael Young"
```

--

Your turn: Get the year column by its name

--


```r
# Get the year column
recent_nobel_med$nobel_prize_year
```

```
##  [1] 2020 2020 2020 2019 2019 2019 2018 2018 2017 2017 2017
```

---

# Rename a column using `colnames()`


```r
colnames(recent_nobel_med)
```

```
## [1] "nobel_prize_winners" "nobel_prize_year"    "nobel_prize_topic"
```

--


```r
# Rename the first column "laureates"
colnames(recent_nobel_med)[1] &lt;- "laureates"
```

--


```r
head(recent_nobel_med)
```

```
##            laureates nobel_prize_year
## 1       Harvey Alter             2020
## 2   Michael Houghton             2020
## 3       Charles Rice             2020
## 4    Peter Ratcliffe             2019
## 5 William Kaelin Jr.             2019
## 6      Gregg Semenza             2019
##                                               nobel_prize_topic
## 1                                Discovery of hepatitis C virus
## 2                                Discovery of hepatitis C virus
## 3                                Discovery of hepatitis C virus
## 4 Discovery of how cells sense and adapt to oxygen availability
## 5 Discovery of how cells sense and adapt to oxygen availability
## 6 Discovery of how cells sense and adapt to oxygen availability
```

---

# Your turn: Renameing columns

Rename the second column "year" and the third "research_topic"

--


```r
colnames(recent_nobel_med)[2:3] &lt;- c("year", "research_topic")
print(recent_nobel_med)
```

```
##             laureates year
## 1        Harvey Alter 2020
## 2    Michael Houghton 2020
## 3        Charles Rice 2020
## 4     Peter Ratcliffe 2019
## 5  William Kaelin Jr. 2019
## 6       Gregg Semenza 2019
## 7       James Allison 2018
## 8        Tasuku Honjo 2018
## 9        Jeffery Hall 2017
## 10    Michael Rosbach 2017
## 11      Michael Young 2017
##                                                                   research_topic
## 1                                                 Discovery of hepatitis C virus
## 2                                                 Discovery of hepatitis C virus
## 3                                                 Discovery of hepatitis C virus
## 4                  Discovery of how cells sense and adapt to oxygen availability
## 5                  Discovery of how cells sense and adapt to oxygen availability
## 6                  Discovery of how cells sense and adapt to oxygen availability
## 7  Cancer immunotherapy by inhibiting the negative regulation of immune response
## 8  Cancer immunotherapy by inhibiting the negative regulation of immune response
## 9                           Discovery of the molecular basis of circadian rhythm
## 10                          Discovery of the molecular basis of circadian rhythm
## 11                          Discovery of the molecular basis of circadian rhythm
```

---

# Rows can be accessed with their names too, but in a different fashion.

We'll use a small gene information table that makes more sense. Note that you can also name columns when you construct it.


```r
gene_model &lt;- data.frame(
  row.names = c("Gapdh", "Mnx1", "Chat", "Vglut1"),
  # Naming columns with column name = vector
  gene_type = c("Enzyme", "Transcription factor", "Enzyme", "Transporter"),
  id = c(
    "ENSMUSG00000057666",
    "ENSMUSG00000001566",
    "ENSMUSG00000100241",
    "ENSMUSG00000070570"
    )
  )
```

---

# Example tiny data frame


```r
print(gene_model)
```

```
##                   gene_type                 id
## Gapdh                Enzyme ENSMUSG00000057666
## Mnx1   Transcription factor ENSMUSG00000001566
## Chat                 Enzyme ENSMUSG00000100241
## Vglut1          Transporter ENSMUSG00000070570
```

--

Note that there are no column named "row.names". The gene symbols were not stored in a column but as row names, which can be accessed by `rownames()`, which takes a data frame as its argument, and returns the row names.

--


```r
rownames(gene_model)
```

```
## [1] "Gapdh"  "Mnx1"   "Chat"   "Vglut1"
```

---

# Using `rownames()`

`rownames()` works very similar to `colnames()` when you want to rename things. For example, the official symbol for Chat (CHoline AcetylTransferase) is Slc18a3. Let's rename it to the official symbol.

--


```r
rownames(gene_model)[3] &lt;- "Slc18a3"
print(gene_model)
```

```
##                    gene_type                 id
## Gapdh                 Enzyme ENSMUSG00000057666
## Mnx1    Transcription factor ENSMUSG00000001566
## Slc18a3               Enzyme ENSMUSG00000100241
## Vglut1           Transporter ENSMUSG00000070570
```

---

# Your turn: Renaming rows

The official symbol for Vglut1 is "Slc17a7". Let's rename the row.

--


```r
rownames(gene_model)[4] &lt;- "Slc17a7"
print(gene_model)
```

```
##                    gene_type                 id
## Gapdh                 Enzyme ENSMUSG00000057666
## Mnx1    Transcription factor ENSMUSG00000001566
## Slc18a3               Enzyme ENSMUSG00000100241
## Slc17a7          Transporter ENSMUSG00000070570
```

---

# Access rows by their names using square brackets


```r
# Get the Mnx1 row
gene_model["Mnx1", ]
```

```
##                 gene_type                 id
## Mnx1 Transcription factor ENSMUSG00000001566
```

--

Note that square brackets can take a vector as an input.


```r
# Get both the Mnx1 and Vglut1 row
gene_model[c("Mnx1", "Slc17a7"), ]
```

```
##                    gene_type                 id
## Mnx1    Transcription factor ENSMUSG00000001566
## Slc17a7          Transporter ENSMUSG00000070570
```

---

# Square brackets can be used for colnames, too

This can be useful when you need to get multiple columns by their names.

--


```r
# Get the gene_type and id column
gene_model[, c("gene_type", "id")]
```

```
##                    gene_type                 id
## Gapdh                 Enzyme ENSMUSG00000057666
## Mnx1    Transcription factor ENSMUSG00000001566
## Slc18a3               Enzyme ENSMUSG00000100241
## Slc17a7          Transporter ENSMUSG00000070570
```

---

# Take-home messages

- Vectors can be subset with indices.

--

- You can generate index vector (just a numeric vector) by first setting a criteria with logical operations and then turnning it into a numeric vector.

--

- Vectors of the same length can be used to build a data frame in which each vector becomes a column.

--

- Data in a data frame can be accessed by indices, too.

--

- In a data frame, rows and columns have names that can also be used to access items.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
